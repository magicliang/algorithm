package algorithm.sorting;

/**
 * 快速排序算法实现类
 * <p>
 * 快速排序是一种高效的分治排序算法，由C.A.R. Hoare在1960年提出。
 * 其核心思想是选择一个"基准"(pivot)元素，通过一趟排序将待排记录分隔成独立的两部分，
 * 其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，
 * 以达到整个序列有序。
 * </p>
 *
 * <p>
 * <strong>算法特点：</strong>
 * <ul>
 *   <li>分治策略：将大问题分解为小问题递归解决</li>
 *   <li>原地排序：空间复杂度O(log n)，仅使用递归栈空间</li>
 *   <li>不稳定排序：相等元素的相对位置可能改变</li>
 *   <li>平均性能优秀：期望时间复杂度O(n log n)</li>
 * </ul>
 * </p>
 *
 * <p>
 * <strong>实现方案：</strong>
 * <ul>
 *   <li>Lomuto分区方案：逻辑清晰，以末尾元素为pivot</li>
 *   <li>Hoare分区方案：交换次数更少，性能更优</li>
 *   <li>三数取中法：避免最坏情况，提高平均性能</li>
 *   <li>尾递归优化：控制递归深度，防止栈溢出</li>
 * </ul>
 * </p>
 *
 * <p>
 * <strong>分区方案图解对比：</strong>
 * </p>
 * <pre>
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │                           Lomuto 分区方案 (partition)                           │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │ 特点：单向扫描，以末尾元素为pivot，逻辑简单直观                                    │
 * │                                                                                 │
 * │ 初始状态：[4, 2, 8, 1, 9, 3, 7, 5]  pivot = 5 (末尾元素)                        │
 * │           ↑                    ↑                                                │
 * │           i=-1 (小值区末尾)     j=0 (扫描指针)                                    │
 * │                                                                                 │
 * │ 扫描过程：j 从左到右单向扫描，遇到小于pivot的元素就与i+1位置交换                    │
 * │                                                                                 │
 * │ Step 1: j=0, arr[0]=4 < 5 → i++, swap(i,j) → [4, 2, 8, 1, 9, 3, 7, 5]         │
 * │         ↑  ↑                                                                    │
 * │         i=0 j=1                                                                 │
 * │                                                                                 │
 * │ Step 2: j=1, arr[1]=2 < 5 → i++, swap(i,j) → [4, 2, 8, 1, 9, 3, 7, 5]         │
 * │            ↑  ↑                                                                 │
 * │            i=1 j=2                                                              │
 * │                                                                                 │
 * │ Step 3: j=2, arr[2]=8 ≥ 5 → 不交换，j继续                                       │
 * │               ↑                                                                 │
 * │               j=3                                                               │
 * │                                                                                 │
 * │ 最终结果：[4, 2, 1, 3, 9, 8, 7, 5] → 交换pivot到正确位置 → [4, 2, 1, 3, 5, 8, 7, 9] │
 * │                    ↑                                           ↑               │
 * │                  小值区                                      pivot位置          │
 * └─────────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │                           Hoare 分区方案 (partition2)                          │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │ 特点：双向扫描，以首元素为pivot，交换次数更少，性能更优                            │
 * │                                                                                 │
 * │ 初始状态：[5, 2, 8, 1, 9, 3, 7, 4]  pivot = 5 (首元素)                          │
 * │           ↑                    ↑                                                │
 * │           i=0 (左指针)          j=7 (右指针)                                      │
 * │                                                                                 │
 * │ 扫描过程：双指针从两端向中间移动，寻找需要交换的元素对                             │
 * │                                                                                 │
 * │ Step 1: 右指针j向左找 < pivot的元素：j=7, arr[7]=4 < 5 ✓                         │
 * │         左指针i向右找 ≥ pivot的元素：i=0, arr[0]=5 ≥ 5 ✓                         │
 * │         交换 arr[0] ↔ arr[7] → [4, 2, 8, 1, 9, 3, 7, 5]                        │
 * │                                                                                 │
 * │ Step 2: 继续扫描：j向左找 < 5的元素，i向右找 ≥ 5的元素                            │
 * │         j=6, arr[6]=7 ≥ 5 → j=5, arr[5]=3 < 5 ✓                                │
 * │         i=1, arr[1]=2 < 5 → i=2, arr[2]=8 ≥ 5 ✓                                │
 * │         交换 arr[2] ↔ arr[5] → [4, 2, 3, 1, 9, 8, 7, 5]                        │
 * │                                                                                 │
 * │ Step 3: 继续直到 i ≥ j，最后将pivot交换到相遇位置                                │
 * │         最终结果：[4, 2, 3, 1, 5, 8, 7, 9]                                      │
 * │                           ↑                                                     │
 * │                        pivot位置                                                │
 * └─────────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │                                性能对比分析                                      │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │ 方案特性        │ Lomuto分区              │ Hoare分区                           │
 * ├─────────────────┼─────────────────────────┼─────────────────────────────────────┤
 * │ 扫描方向        │ 单向（左→右）            │ 双向（左↔右）                        │
 * │ Pivot选择       │ 末尾元素                │ 首元素                              │
 * │ 交换次数        │ 较多（每个小元素都交换） │ 较少（只交换违规元素对）              │
 * │ 代码复杂度      │ 简单直观                │ 稍复杂（需注意扫描顺序）              │
 * │ 缓存友好性      │ 较好（顺序访问）         │ 一般（跳跃访问）                     │
 * │ 实际性能        │ 中等                    │ 更优（减少交换操作）                  │
 * │ 稳定性          │ 实现简单不易出错         │ 需要注意边界条件                     │
 * └─────────────────┴─────────────────────────┴─────────────────────────────────────┘
 *
 * <p>
 * <strong>核心认知：分区方案的"违背性质"机制</strong>
 * </p>
 * <pre>
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │                            违背性质的本质差异                                    │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │                                                                                 │
 * │ 🔍 Lomuto分区的违背性质：                                                        │
 * │    维护性质：左区间严格 < pivot                                                  │
 * │    违背条件：当 arr[j] >= pivot 时违背了 < pivot 的性质                          │
 * │    处理策略：违背时不交换，让该元素留在右区间                                     │
 * │                                                                                 │
 * │    if (arr[j] < target) {     // 严格 < pivot                                   │
 * │        i++;                   // 扩张左区间                                      │
 * │        swap(arr[i], arr[j]);  // 交换到左区间                                    │
 * │    }                          // >= pivot 的元素自然留在右区间                   │
 * │                                                                                 │
 * │ ─────────────────────────────────────────────────────────────────────────────── │
 * │                                                                                 │
 * │ 🔍 Hoare分区的违背性质：                                                         │
 * │    维护性质：左区间 <= pivot，右区间 >= pivot                                    │
 * │    违背条件：左指针遇到 > pivot 的元素，右指针遇到 < pivot 的元素                 │
 * │    处理策略：找到违背性质的元素对后进行交换                                       │
 * │                                                                                 │
 * │    while (arr[j] >= pivot) j--;  // 右指针寻找违背 >= pivot 性质的元素           │
 * │    while (arr[i] <= pivot) i++;  // 左指针寻找违背 <= pivot 性质的元素           │
 * │    swap(arr[i], arr[j]);         // 交换违背性质的元素对                         │
 * │                                                                                 │
 * │ ─────────────────────────────────────────────────────────────────────────────── │
 * │                                                                                 │
 * │ 💡 关键洞察：                                                                    │
 * │    • Lomuto违背的是严格 < 的性质，处理方式是"跳过不符合的元素"                    │
 * │    • Hoare违背的是 <= 和 >= 的性质，处理方式是"交换违背的元素对"                  │
 * │    • 这种设计差异是两种方案性能差异的根本原因                                     │
 * │    • Lomuto每遇到小元素就交换，Hoare只交换真正需要交换的元素                      │
 * │                                                                                 │
 * └─────────────────────────────────────────────────────────────────────────────────┘
 * </pre>
 *
 * <p>
 * <strong>🌳 递归树复杂度分析：多叉树 vs 单支递归的本质差异</strong>
 * </p>
 * <pre>
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │                        传统快速排序：完全二叉递归树                              │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │                                                                                 │
 * │                                T(n)                                             │
 * │                               /   \                                             │
 * │                          T(n/2)   T(n/2)         ← 第1层：2个子问题             │
 * │                          /   \     /   \                                        │
 * │                     T(n/4) T(n/4) T(n/4) T(n/4)  ← 第2层：4个子问题             │
 * │                      / \   / \     / \   / \                                    │
 * │                    ...  ... ...   ... ... ...   ← 第3层：8个子问题             │
 * │                                                                                 │
 * │ 📊 工作量分析：                                                                  │
 * │    • 层数：log n                                                                │
 * │    • 第k层节点数：2^k                                                           │
 * │    • 第k层总工作量：2^k × O(n/2^k) = O(n)                                       │
 * │    • 每层工作量都是 O(n)，共 log n 层                                            │
 * │                                                                                 │
 * │ 🔢 总复杂度计算：                                                                │
 * │    总工作量 = O(n) + O(n) + O(n) + ... (log n 层)                               │
 * │             = O(n) × log n                                                      │
 * │             = O(n log n)                                                        │
 * │                                                                                 │
 * │ 💡 关键特征：每层工作量保持恒定 O(n)                                             │
 * └─────────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │                        TopK问题：部分递归单支树                                  │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │                                                                                 │
 * │                                T(n)                                             │
 * │                               /                                                 │
 * │                          T(n/2)              ← 第1层：只递归1个分支             │
 * │                          /                                                      │
 * │                     T(n/4)                   ← 第2层：只递归1个分支             │
 * │                     /                                                           │
 * │                T(n/8)                        ← 第3层：只递归1个分支             │
 * │                /                                                                │
 * │              ...                             ← 持续单支递归                     │
 * │             /                                                                   │
 * │         T(1)                                 ← 最终到达叶子节点                 │
 * │                                                                                 │
 * │ 📊 工作量分析：                                                                  │
 * │    • 层数：log n                                                                │
 * │    • 第k层节点数：1（只有一个分支）                                              │
 * │    • 第k层工作量：1 × O(n/2^k) = O(n/2^k)                                       │
 * │    • 每层工作量呈几何级数递减                                                    │
 * │                                                                                 │
 * │ 🔢 总复杂度计算（几何级数收敛）：                                                 │
 * │    总工作量 = O(n) + O(n/2) + O(n/4) + O(n/8) + ...                             │
 * │             = O(n) × (1 + 1/2 + 1/4 + 1/8 + ...)                               │
 * │             = O(n) × Σ(1/2^k) from k=0 to ∞                                    │
 * │             = O(n) × 2                                                          │
 * │             = O(n)                                                              │
 * │                                                                                 │
 * │ 💡 关键特征：工作量几何级数收敛到常数倍                                          │
 * └─────────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │                          🧠 核心理论洞察                                         │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │                                                                                 │
 * │ 🎯 多叉树 → 单支递归的复杂度变化规律：                                           │
 * │                                                                                 │
 * │ ┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐       │
 * │ │   递归模式      │   分支数量      │   工作量分布    │   总复杂度      │       │
 * │ ├─────────────────┼─────────────────┼─────────────────┼─────────────────┤       │
 * │ │ 完全二叉递归    │ 每层 2^k 个分支 │ 每层恒定 O(n)   │ O(n log n)      │       │
 * │ │ 部分单支递归    │ 每层 1 个分支   │ 几何级数递减    │ O(n)            │       │
 * │ │ 完全三叉递归    │ 每层 3^k 个分支 │ 每层恒定 O(n)   │ O(n log n)      │       │
 * │ │ k叉树递归       │ 每层 k^i 个分支 │ 每层恒定 O(n)   │ O(n log n)      │       │
 * │ └─────────────────┴─────────────────┴─────────────────┴─────────────────┘       │
 * │                                                                                 │
 * │ 🔑 关键认知：                                                                    │
 * │                                                                                 │
 * │ 1️⃣ 多叉树特征：                                                                 │
 * │    • 每层都要处理所有分支                                                        │
 * │    • 工作量在每层保持恒定 O(n)                                                   │
 * │    • 总复杂度 = 层数 × 每层工作量 = O(log n) × O(n) = O(n log n)                │
 * │                                                                                 │
 * │ 2️⃣ 单支递归特征：                                                               │
 * │    • 每层只处理一个分支（智能剪枝）                                              │
 * │    • 工作量呈几何级数递减                                                        │
 * │    • 几何级数收敛：Σ(n/2^k) = O(n)                                              │
 * │                                                                                 │
 * │ 3️⃣ 适用场景：                                                                   │
 * │    • 搜索问题：二分搜索、BST查找                                                 │
 * │    • 选择问题：TopK、快速选择算法                                                │
 * │    • 优化问题：三分搜索、黄金分割搜索                                            │
 * │    • 决策问题：博弈树剪枝、A*搜索                                                │
 * │                                                                                 │
 * │ 4️⃣ 数学本质：                                                                   │
 * │    • 多叉树：算术级数求和 → O(n log n)                                           │
 * │    • 单支树：几何级数求和 → O(n)                                                 │
 * │    • 剪枝效应：从指数级分支缩减到线性路径                                        │
 * │                                                                                 │
 * │ 💡 终极洞察：                                                                    │
 * │    当算法能够智能地选择"最有价值的分支"进行递归时，                               │
 * │    复杂度从 O(n log n) 降低到 O(n)，这是分治算法优化的核心思想！                 │
 * │                                                                                 │
 * └─────────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │                    🎯 核心认知：多叉树→单支递归的复杂度变化                      │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │                                                                                 │
 * │ 🧠 **关键问题：多叉树变成单支前进，分解和合并的解必然就是 O(n) 吗？**            │
 * │                                                                                 │
 * │ ✅ **答案：是的！这是一个深刻的算法洞察！**                                      │
 * │                                                                                 │
 * │ 🔍 **数学原理：**                                                                │
 * │                                                                                 │
 * │ 📊 多叉树递归模式：                                                              │
 * │    T(n) = k×T(n/k) + O(n)  // k个分支，每个处理n/k规模                          │
 * │    • 每层工作量：k × O(n/k) = O(n)                                              │
 * │    • 层数：log n                                                                │
 * │    • 总复杂度：O(n) × log n = **O(n log n)**                                    │
 * │                                                                                 │
 * │ 📈 单支递归模式：                                                                │
 * │    T(n) = 1×T(n/2) + O(n)  // 只有1个分支                                       │
 * │    • 每层工作量：O(n), O(n/2), O(n/4), ...                                      │
 * │    • 几何级数收敛：O(n) × (1 + 1/2 + 1/4 + ...) = **O(n)**                     │
 * │                                                                                 │
 * │ ⚡ **性能对比：**                                                                 │
 * │                                                                                 │
 * │ ┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐       │
 * │ │   递归策略      │   分支处理      │   工作量分布    │   总复杂度      │       │
 * │ ├─────────────────┼─────────────────┼─────────────────┼─────────────────┤       │
 * │ │ 完全多叉递归    │ 处理所有分支    │ 每层恒定 O(n)   │ O(n log n)      │       │
 * │ │ 智能单支递归    │ 选择最优分支    │ 几何级数递减    │ O(n)            │       │
 * │ │ 传统快速排序    │ 左右都要递归    │ 每层恒定 O(n)   │ O(n log n)      │       │
 * │ │ TopK快速选择    │ 只递归目标分支  │ 几何级数递减    │ O(n)            │       │
 * │ │ 二分搜索        │ 只搜索一半      │ 几何级数递减    │ O(log n)        │       │
 * │ │ 三分搜索        │ 只递归1/3区间   │ 几何级数递减    │ O(log n)        │       │
 * │ └─────────────────┴─────────────────┴─────────────────┴─────────────────┘       │
 * │                                                                                 │
 * │ 🎯 **适用场景：**                                                                │
 * │    • 搜索问题：二分搜索、BST查找、三分搜索                                       │
 * │    • 选择问题：TopK、快速选择、中位数查找                                        │
 * │    • 优化问题：黄金分割搜索、单峰函数极值                                        │
 * │    • 决策问题：博弈树剪枝、A*搜索、分支限界                                      │
 * │                                                                                 │
 * │ 🔑 **核心机制：**                                                                │
 * │    1️⃣ **剪枝效应**：智能排除不必要的搜索空间                                    │
 * │    2️⃣ **几何收敛**：工作量呈指数级递减 (n → n/2 → n/4 → ...)                    │
 * │    3️⃣ **精准分治**：只解决包含答案的子问题                                       │
 * │    4️⃣ **数学本质**：几何级数求和收敛到常数倍                                     │
 * │                                                                                 │
 * │ 💡 **终极洞察：**                                                                │
 * │    当分治算法能够通过某种策略（如二分判断、TopK选择、剪枝条件等）               │
 * │    智能地识别并只处理\"最有价值的分支\"时，算法复杂度会从传统的                   │
 * │    O(n log n) 降低到 O(n) 甚至 O(log n)。                                       │
 * │                                                                                 │
 * │    这种\"多叉→单支\"的转换是算法优化的黄金法则，体现了：                           │
 * │    **\"智能选择 > 暴力遍历\"** 的算法设计哲学！                                   │
 * │                                                                                 │
 * │ 🎯 **剪枝前后工作量的本质变化：**                                                │
 * │                                                                                 │
 * │    • **剪枝前（传统多叉）**：每层工作量恒定为 n                                  │
 * │      总工作量 = n × log n = O(n log n)                                          │
 * │                                                                                 │
 * │    • **剪枝后（单支递归）**：每层工作量变成原来的 1/2                            │
 * │      每层工作量 = n, n/2, n/4, n/8, ...                                         │
 * │      相当于工作量变成了原来的 **log n 分之一**                                   │
 * │      总工作量 = n × (1 + 1/2 + 1/4 + ...) = O(n)                               │
 * │                                                                                 │
 * │    • **数学本质**：几何级数收敛效应                                              │
 * │      Σ(1/2^k) = 2，所以总工作量从 n×log n 降为 n×2 = O(n)                      │
 * │                                                                                 │
 * │    这种"每层工作量几何递减"的特性是单支递归算法高效的根本原因！                   │
 * │                                                                                 │
 * └─────────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │              🎯 复杂度差异的直观证明：为什么是 log n 倍而不是 n 倍？              │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │                                                                                 │
 * │ ❓ **核心问题：为什么复杂度差异是 log n 倍，而不是 n 倍？**                       │
 * │                                                                                 │
 * │ 🔍 **直观分析（不使用几何级数收敛）：**                                          │
 * │                                                                                 │
 * │ 📊 **具体数值示例 (n = 16)：**                                                   │
 * │                                                                                 │
 * │ ┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐       │
 * │ │   算法类型      │   每层工作量    │   层数          │   总工作量      │       │
 * │ ├─────────────────┼─────────────────┼─────────────────┼─────────────────┤       │
 * │ │ 满决策树快排    │ 16,16,16,16     │ 4层             │ 64 = 16×4       │       │
 * │ │ 单支剪枝TopK    │ 16,8,4,2        │ 4层             │ 30 ≈ 16×2       │       │
 * │ │ 性能提升倍数    │ 逐层递减        │ 相同            │ 64/30 ≈ 2倍     │       │
 * │ └─────────────────┴─────────────────┴─────────────────┴─────────────────┘       │
 * │                                                                                 │
 * │ 🧮 **数学分析：**                                                                │
 * │                                                                                 │
 * │ 1️⃣ **满决策树总工作量：**                                                       │
 * │    • 每层工作量恒定：n                                                           │
 * │    • 层数：log n                                                                │
 * │    • 总工作量：n × log n                                                        │
 * │                                                                                 │
 * │ 2️⃣ **单支剪枝总工作量：**                                                       │
 * │    • 第k层工作量：n/2^k                                                         │
 * │    • 层数：log n                                                                │
 * │    • 总工作量：n + n/2 + n/4 + ... + n/2^(log n-1)                             │
 * │                                                                                 │
 * │ 3️⃣ **关键洞察：为什么不是 n 倍差异？**                                          │
 * │                                                                                 │
 * │    ❌ **错误理解：**                                                             │
 * │       认为单支剪枝只处理 1 个节点，满树处理 n/2 个节点                           │
 * │       所以差异应该是 (n/2)/1 = n/2 倍                                           │
 * │                                                                                 │
 * │    ✅ **正确理解：**                                                             │
 * │       • 满决策树：每层处理 n 的工作量，共 log n 层                               │
 * │       • 单支剪枝：每层处理递减的工作量，但仍有 log n 层                          │
 * │       • 关键差异在于"每层工作量的分布模式"，不是"节点数量"                        │
 * │                                                                                 │
 * │ 4️⃣ **直观证明（逐层对比）：**                                                   │
 * │                                                                                 │
 * │    设 n = 2^k，则有 k = log n 层                                                │
 * │                                                                                 │
 * │    满决策树每层工作量：                                                          │
 * │    第0层：n,  第1层：n,  第2层：n,  ...,  第k-1层：n                            │
 * │    总和：n × k = n × log n                                                      │
 * │                                                                                 │
 * │    单支剪枝每层工作量：                                                          │
 * │    第0层：n,  第1层：n/2,  第2层：n/4,  ...,  第k-1层：n/2^(k-1)                │
 * │    总和：n × (1 + 1/2 + 1/4 + ... + 1/2^(k-1))                                 │
 * │         < n × (1 + 1/2 + 1/4 + ... + 1/2 + ...)  [无穷级数]                    │
 * │         = n × 2                                                                 │
 * │                                                                                 │
 * │    复杂度比值：(n × log n) / (n × 2) = log n / 2 ≈ log n                       │
 * │                                                                                 │
 * │ 💡 **核心洞察：**                                                                │
 * │                                                                                 │
 * │    复杂度差异来源于"工作量分布模式"的不同：                                       │
 * │    • 满决策树：均匀分布（每层相同）                                              │
 * │    • 单支剪枝：指数衰减分布（每层递减）                                          │
 * │                                                                                 │
 * │    差异倍数 = 均匀分布总和 / 指数衰减分布总和                                    │
 * │             = (n × log n) / (n × 常数)                                          │
 * │             = log n                                                             │
 * │                                                                                 │
 * │ 🎯 **为什么不是 n 倍？**                                                         │
 * │                                                                                 │
 * │    因为我们比较的不是"最后一层的节点数量差异"，                                   │
 * │    而是"整个算法的总工作量差异"。                                                 │
 * │                                                                                 │
 * │    最后一层节点数差异确实是 n/2 vs 1 = n/2 倍，                                 │
 * │    但总工作量差异是所有层的累积效应，结果是 log n 倍。                           │
 * │                                                                                 │
 * │ 🔑 **数学本质：**                                                                │
 * │    • 节点数差异：线性关系 (n/2 vs 1)                                            │
 * │    • 工作量差异：对数关系 (log n 倍)                                             │
 * │    • 算法复杂度关注的是总工作量，不是单层节点数                                   │
 * │                                                                                 │
 * └─────────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────────────────┐
 * │                    🔍 重要澄清：递归树底层节点数量的常见误解                      │
 * ├─────────────────────────────────────────────────────────────────────────────────┤
 * │                                                                                 │
 * │ ❓ **常见疑问：最后一层的节点数量是 log n 吗？**                                  │
 * │                                                                                 │
 * │ ❌ **错误理解：**                                                                │
 * │    最后一层节点数 = log n                                                        │
 * │                                                                                 │
 * │ ✅ **正确理解：**                                                                │
 * │    • 树的层数 = log n                                                           │
 * │    • 最后一层节点数 = 2^(log n - 1) = n/2                                       │
 * │    • 叶子节点总数 ≈ n/2 (远大于 log n)                                          │
 * │                                                                                 │
 * │ 📊 **数值示例 (n = 16)：**                                                       │
 * │                                                                                 │
 * │                    T(16)           ← 第0层：1个节点                             │
 * │                   /    \\                                                        │
 * │               T(8)      T(8)       ← 第1层：2个节点                             │
 * │              /  \\      /  \\                                                     │
 * │           T(4) T(4)  T(4) T(4)     ← 第2层：4个节点                             │
 * │           / \\  / \\   / \\  / \\                                                   │
 * │         T(2).....................  ← 第3层：8个节点 (最后一层)                  │
 * │                                                                                 │
 * │    结果对比：                                                                    │
 * │    • log n = log₂ 16 = 4 (层数)                                                 │
 * │    • 最后一层节点数 = 2³ = 8                                                     │
 * │    • 8 ≠ 4，所以最后一层节点数 ≠ log n                                           │
 * │                                                                                 │
 * │ 🔑 **关键数学关系：**                                                            │
 * │                                                                                 │
 * │ ┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐       │
 * │ │   树的特征      │   多叉递归树    │   单支递归树    │   数学关系      │       │
 * │ ├─────────────────┼─────────────────┼─────────────────┼─────────────────┤       │
 * │ │ 总层数          │ log n           │ log n           │ 相同            │       │
 * │ │ 最后一层节点数  │ n/2             │ 1               │ 指数级差异      │       │
 * │ │ 叶子节点总数    │ ≈ n/2           │ 1               │ 线性 vs 常数    │       │
 * │ │ 最后一层工作量  │ O(n/2)          │ O(1)            │ 线性 vs 常数    │       │
 * │ └─────────────────┴─────────────────┴─────────────────┴─────────────────┘       │
 * │                                                                                 │
 * │ 💡 **为什么会有这个混淆？**                                                      │
 * │    1. 层数概念：递归树的层数确实是 log n                                         │
 * │    2. 节点数概念：但每层的节点数是指数增长的 (2^k)                               │
 * │    3. 底层特征：最后一层包含了约一半的总节点数                                   │
 * │                                                                                 │
 * │ 🎯 **核心洞察：**                                                                │
 * │    • 多叉递归：最后一层有 n/2 个节点，每个处理 O(1)，总计 O(n/2)                │
 * │    • 单支递归：最后一层有 1 个节点，处理 O(1)，总计 O(1)                        │
 * │    • 这种"节点数量的指数级差异"是性能差异的根本原因                              │
 * │                                                                                 │
 * │ 🔢 **数学本质：**                                                                │
 * │    递归树的"底层工作量"不是由层数决定的，而是由底层节点数量决定的！               │
 * │    • log n 是深度概念                                                           │
 * │    • n/2 vs 1 是广度概念                                                        │
 * │    • 算法复杂度由深度×广度共同决定                                               │
 * │                                                                                 │
 * └─────────────────────────────────────────────────────────────────────────────────┘
 * </pre>
 * </pre>
 *
 * @author magicliang
 * @version 1.0
 * @see <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort - Wikipedia</a>
 * @since 2025-08-21
 */
public class QuickSort {

    /**
     * 基于Lomuto分区方案的快速排序入口方法
     * <p>
     * 使用递归分治策略，通过 pivot 分割区间，逐步将每个元素归位。
     * 这是最基础的快速排序实现，使用Lomuto分区方案（以末尾元素为pivot）。
     * </p>
     *
     * <p>
     * <strong>算法复杂度分析：</strong>
     * </p>
     * <ul>
     *   <li><strong>时间复杂度：</strong>
     *     <ul>
     *       <li>最好情况：O(n log n) - 每次分区都能将数组平均分成两部分</li>
     *       <li>平均情况：O(n log n) - 随机选择基准元素的期望性能</li>
     *       <li>最坏情况：O(n²) - 每次分区都极不平衡（如已排序数组选择首/末元素作为基准）</li>
     *     </ul>
     *   </li>
     *   <li><strong>空间复杂度：</strong>
     *     <ul>
     *       <li>最好情况：O(log n) - 递归调用栈深度为 log n</li>
     *       <li>最坏情况：O(n) - 递归调用栈深度为 n（退化为链式递归）</li>
     *       <li>平均情况：O(log n) - 期望递归深度为 log n</li>
     *     </ul>
     *   </li>
     * </ul>
     *
     * <p>
     * <strong>复杂度证明：</strong><br>
     * 设T(n)为排序n个元素的时间复杂度，分区操作需要O(n)时间，则：
     * <ul>
     *   <li>最好情况：T(n) = 2T(n/2) + O(n)，根据主定理得T(n) = O(n log n)</li>
     *   <li>最坏情况：T(n) = T(n-1) + O(n)，递推得T(n) = O(n²)</li>
     *   <li>平均情况：期望分区比例为1:1，故平均复杂度为O(n log n)</li>
     * </ul>
     * </p>
     *
     * @param arr 待排序的整型数组（允许 null 或空数组）
     * @return 排序后的原数组引用（对于null输入返回null）
     * @throws ArrayIndexOutOfBoundsException 当数组为null时调用arr.length会抛出此异常
     */
    public static int[] quickSortLomuto(int[] arr) {
        // 边界检查：null数组无法获取长度，会抛出异常
        if (arr == null) {
            return null;
        }
        // 将全局排序委托给区间版本：[0, length-1]
        return quickSortLomuto(arr, 0, arr.length - 1);
    }

    /**
     * 基于Lomuto分区方案的快速排序递归主函数：对子数组 [begin, end] 进行排序
     * 实现原地（in-place）排序，不额外分配空间
     * <p>
     * 核心流程：
     * 1. 分区（partitionLomuto）：选出一个 pivot，将其放置到最终有序位置 pivotal
     * 2. 分治（divide & conquer）：
     * - 递归排序左半部分 [begin, pivotal-1]
     * - 递归排序右半部分 [pivotal+1, end]
     * <p>
     * 关键设计：
     * - 使用 begin >= end 作为递归终止条件，防止 pivotal±1 导致的无限递归
     * - 所有操作均在原数组上进行，空间复杂度 O(log n)（仅递归栈）
     *
     * @param arr 待排序数组
     * @param begin 当前排序区间的起始索引（包含）
     * @param end 当前排序区间的结束索引（包含）
     * @return 排序完成后的原数组引用
     */
    public static int[] quickSortLomuto(int[] arr, int begin, int end) {
        // ======== 递归终止条件：无需排序的情况 ========
        // 以下情况直接返回，不再递归：
        // 1. 数组为空或未初始化
        // 2. 区间无效（begin >= end）——这是 pivotal±1 不越界崩溃的关键防护！
        //    - pivotal-1 可能 < begin（如 pivotal == begin）
        //    - pivotal+1 可能 > end（如 pivotal == end）
        //    若无此判断，将导致无限递归 → StackOverflowError
        if (arr == null || begin >= end) {
            return arr;
        }

        // ======== 分治三步走 ========
        // 1. 分区：将当前区间划分为左小右大两部分，并返回 pivot 的最终位置
        int pivotal = partitionLomuto(arr, begin, end);

        // 2. 递归处理左半部分：[begin, pivotal - 1]
        //    注意：pivotal 已就位，不再参与排序
        quickSortLomuto(arr, begin, pivotal - 1);

        // 3. 递归处理右半部分：[pivotal + 1, end]
        //    同样跳过 pivot，只排右边
        quickSortLomuto(arr, pivotal + 1, end);

        // 所有递归完成后，整个数组自然有序
        return arr;
    }

    /**
     * 基于尾递归优化的快速排序入口方法
     * <p>
     * 使用尾递归优化技术，控制递归深度在O(log n)范围内，
     * 避免在极端情况下的栈溢出问题。适用于处理超大数据集。
     * </p>
     *
     * @param arr 待排序的整型数组（允许 null 或空）
     * @return 排序后的原数组（null 或已排序）
     */
    public static int[] quickSortTailRecursive(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return arr;
        }
        return quickSortTailRecursive(arr, 0, arr.length - 1);
    }

    /**
     * 基于三数取中法的尾递归优化快速排序实现
     * <p>
     * 为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，仅对较短的子数组进行递归。
     * 由于较短子数组的长度不会超过 n/2，因此这种方法能确保递归深度不超过 logn
     * </p>
     *
     * <p>
     * <strong>尾递归优化的快速排序特点：</strong>
     * </p>
     * <ul>
     *   <li>使用迭代+递归混合模式，将递归深度控制在O(log n)</li>
     *   <li>每次只递归处理较短的子区间，避免栈溢出</li>
     *   <li>较长的子区间通过迭代处理，减少栈帧创建</li>
     *   <li>使用三数取中法选择pivot，避免最坏情况</li>
     * </ul>
     *
     * <p>
     * <strong>算法流程：</strong>
     * </p>
     * <ol>
     *   <li>使用while循环替代纯递归，处理当前区间</li>
     *   <li>每次分区后，比较左右子区间长度</li>
     *   <li>递归处理较短的子区间（保证递归深度）</li>
     *   <li>通过修改begin/end迭代处理较长的子区间</li>
     * </ol>
     *
     * <p>
     * <strong>时间复杂度：</strong> 平均O(n log n)，最坏O(n²)（但概率极低，因使用三数取中法）<br>
     * <strong>空间复杂度：</strong> O(log n)（栈空间，最坏情况）
     * </p>
     *
     * @param arr 待排序数组
     * @param begin 当前排序区间的起始索引（包含）
     * @param end 当前排序区间的结束索引（包含）
     * @return 排序完成后的原数组引用
     */
    public static int[] quickSortTailRecursive(int[] arr, int begin, int end) {
        // ======== 递归终止条件：无需排序的情况 ========
        // 以下情况直接返回，不再递归：
        // 1. 数组为空或未初始化
        // 2. 区间无效（begin >= end）——这是 pivotal±1 不越界崩溃的关键防护！
        //    - pivotal-1 可能 < begin（如 pivotal == begin）
        //    - pivotal+1 可能 > end（如 pivotal == end）
        //    若无此判断，将导致无限递归 → StackOverflowError
        if (arr == null || begin >= end) {
            return arr;
        }

        // 递归排序要像二分一样，迭代处理一个区间
        while (begin < end) {
            // 每一轮查找开始，会重新计算 pivotal
            int pivotal = partitionMedianOfThree(arr, begin, end); // 使用三数取中分区
            // 只排序短区间
            if (pivotal - begin < end - pivotal) {
                quickSortTailRecursive(arr, begin, pivotal - 1);
                // 左区间排好，收窄左区间，进入下一轮循环
                begin = pivotal + 1;
            } else {
                quickSortTailRecursive(arr, pivotal + 1, end);
                // 右区间排好，收窄右区间，进入下一轮循环
                end = pivotal - 1;
            }
        }

        // 当二分结束以后，所有子区间都排好序了
        return arr;

    }

    /**
     * 基于Hoare分区方案的快速排序入口方法
     * <p>
     * 使用Hoare分区方案的快速排序实现，这是由快速排序发明者C.A.R. Hoare
     * 提出的原始分区方案，相比Lomuto方案具有更少的交换次数，在实践中性能更优。
     * </p>
     *
     * <p>
     * <strong>Hoare分区方案特点：</strong>
     * </p>
     * <ul>
     *   <li>双指针从两端向中间扫描</li>
     *   <li>交换次数更少，性能更优</li>
     *   <li>以首元素为pivot</li>
     *   <li>实现稍复杂，但效率更高</li>
     * </ul>
     *
     * @param arr 待排序的整型数组（允许 null 或空）
     * @return 排序后的原数组（null 或已排序）
     */
    public static int[] quickSortHoare(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return arr;
        }
        return quickSortHoare(arr, 0, arr.length - 1);
    }

    /**
     * 基于Hoare分区方案的快速排序递归主函数
     * <p>
     * 使用Hoare分区方案进行递归排序，该方案通过双指针从两端向中间扫描，
     * 减少了交换次数，提高了排序效率。
     * </p>
     *
     * @param arr 待排序数组
     * @param begin 当前排序区间的起始索引（包含）
     * @param end 当前排序区间的结束索引（包含）
     * @return 排序完成后的原数组引用
     */
    public static int[] quickSortHoare(int[] arr, int begin, int end) {
        if (arr == null || begin >= end) {
            return arr;
        }

        // 使用Hoare分区进行分区
        int pivotal = partitionHoare(arr, begin, end);

        // 递归处理左半部分：[begin, pivotal-1]
        quickSortHoare(arr, begin, pivotal - 1);

        // 递归处理右半部分：[pivotal+1, end]
        quickSortHoare(arr, pivotal + 1, end);

        return arr;
    }

    /**
     * 默认快速排序入口方法（向后兼容）
     * <p>
     * 为了保持向后兼容性，该方法委托给性能最优的三数取中法快速排序实现。
     * 推荐在生产环境中使用，具有最佳的平均性能表现。
     * </p>
     *
     * @param arr 待排序的整型数组（允许 null 或空数组）
     * @return 排序后的原数组引用（对于null输入返回null）
     * @see #quickSortMedianOfThree(int[]) 实际执行的方法
     */
    public static int[] quickSort(int[] arr) {
        return quickSortMedianOfThree(arr);
    }

    /**
     * 默认快速排序递归主函数（向后兼容）
     * <p>
     * 为了保持向后兼容性，该方法委托给性能最优的三数取中法快速排序实现。
     * </p>
     *
     * @param arr 待排序数组
     * @param begin 当前排序区间的起始索引（包含）
     * @param end 当前排序区间的结束索引（包含）
     * @return 排序完成后的原数组引用
     * @see #quickSortMedianOfThree(int[], int, int) 实际执行的方法
     */
    public static int[] quickSort(int[] arr, int begin, int end) {
        return quickSortMedianOfThree(arr, begin, end);
    }

    /**
     * 基于三数取中法的快速排序入口方法
     * <p>
     * 基于三数取中法和Hoare分区方案的高效快速排序实现，
     * 这是快速排序的优化版本，在实际应用中性能最佳。
     * </p>
     *
     * <p>
     * <strong>三数取中法快速排序特点：</strong>
     * </p>
     * <ul>
     *   <li>使用三数取中法选择pivot，避免最坏情况</li>
     *   <li>使用Hoare分区方案，减少交换次数</li>
     *   <li>对于大数据集有更好的性能表现</li>
     *   <li>在已排序或逆序数组上表现优异</li>
     * </ul>
     *
     * @param arr 待排序的整型数组（允许 null 或空）
     * @return 排序后的原数组（null 或已排序）
     */
    public static int[] quickSortMedianOfThree(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return arr;
        }
        return quickSortMedianOfThree(arr, 0, arr.length - 1);
    }

    /**
     * 基于三数取中法的快速排序递归主函数
     * <p>
     * 使用三数取中法和Hoare分区方案的高效快速排序实现，
     * 通过选择更好的pivot来避免最坏情况的发生。
     * </p>
     *
     * @param arr 待排序数组
     * @param begin 当前排序区间的起始索引（包含）
     * @param end 当前排序区间的结束索引（包含）
     * @return 排序完成后的原数组引用
     */
    public static int[] quickSortMedianOfThree(int[] arr, int begin, int end) {
        if (arr == null || begin >= end) {
            return arr;
        }

        // 使用三数取中分区进行分区（三数取中法+Hoare分区）
        int pivotal = partitionMedianOfThree(arr, begin, end);

        // 递归处理左半部分：[begin, pivotal-1]
        quickSortMedianOfThree(arr, begin, pivotal - 1);

        // 递归处理右半部分：[pivotal+1, end]
        quickSortMedianOfThree(arr, pivotal + 1, end);

        return arr;
    }

    /**
     * Lomuto分区方案的核心分区操作
     * <p>
     * 将子数组 [begin, end] 按 pivot 值划分为：
     * [ 小于 pivot ]  [ pivot ]  [ 大于等于 pivot ]
     * 并返回 pivot 的最终位置（即"已排好序的中间节点"）
     * </p>
     *
     * <p>
     * 与归并排序不同，快排是"先定位，再分治"：
     * </p>
     * <ul>
     *   <li>先确定一个元素的最终位置（锚点）</li>
     *   <li>再递归处理其左右区间</li>
     * </ul>
     *
     * <p>
     * 使用 Lomuto 方案（以末尾元素为 pivot），逻辑清晰，易于理解
     * </p>
     *
     * @param arr 待分区的数组
     * @param begin 当前处理区间的起始索引（包含）
     * @param end 当前处理区间的结束索引（包含）
     * @return pivot 元素排序后所在的索引位置（分割点）
     */
    static int partitionLomuto(int[] arr, int begin, int end) {
        // 特殊情况：区间只有一个元素，无需分区，直接返回其位置
        if (begin == end) {
            return begin;
        }

        // 【选择基准】以最后一个元素作为 pivot（目标值），这样开闭区间的伸缩就从第一个元素开始
        int target = arr[end];

        // 【初始化双游标】
        // i：指向"小于 pivot"区域的最后一个元素的索引
        //    初始时空区间，故 i = begin - 1
        // j：遍历指针，扫描 [begin, end-1] 的每一个元素
        int i = begin - 1;
        int j = begin;

        // 【主扫描循环】j 从 begin 遍历到 end-1
        // 易错点：j 必须从 begin 开始，不能写死为 0！
        //        因为 begin 可能 > 0（递归中常见）
        while (j <= end - 1) {
            // 【发现小值】若当前元素小于 pivot
            if (arr[j] < target) {
                // 【扩张小值区】i 右移，准备接纳新成员
                i++;
                // 【交换】将 arr[j] 移入小值区末尾
                //       原地操作，不使用额外空间
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                // 此时 arr[i] 属于小值区，i 仍指向其末尾
            }
            // 【推进扫描】j 持续右移，不受交换影响
            j++;
        }

        // 【安置 pivot】
        // 扫描结束后，所有 < target 的元素位于 [begin, i]
        // 所以 pivot 的正确位置是 i + 1
        i++; // pivot 的最终落点

        // 将 pivot（原 arr[end]）与 arr[i] 交换
        // 此时 arr[i] 左边全小，右边全大，完成分区
        int temp = arr[i];
        arr[i] = target;
        arr[end] = temp;

        // 【返回中间节点】
        // 返回 pivot 的最终索引，作为递归分治的分割点
        // 这个位置的元素已经"排好序"，后续不再变动
        return i;
    }

    /**
     * Hoare分区方案的核心分区操作
     * <p>
     * 这是由快速排序发明者C.A.R. Hoare提出的原始分区方案，
     * 相比Lomuto方案具有更少的交换次数，在实践中性能更优。
     * </p>
     *
     * <p>
     * <strong>算法流程：</strong>
     * </p>
     * <ol>
     *   <li>选择区间起始元素作为pivot</li>
     *   <li>使用双指针从两端向中间扫描</li>
     *   <li>左指针寻找大于等于pivot的元素</li>
     *   <li>右指针寻找小于等于pivot的元素</li>
     *   <li>交换找到的元素，继续扫描直到指针相遇</li>
     *   <li>将pivot交换到最终位置</li>
     * </ol>
     *
     * <p>
     * <strong>关键设计要点：</strong>
     * </p>
     * <ul>
     *   <li>选择左端元素为pivot时，必须先从右端开始扫描</li>
     *   <li>这样确保最终相遇位置的元素小于等于pivot</li>
     *   <li>避免了将大于pivot的元素交换到起始位置的错误</li>
     * </ul>
     *
     * <p>
     * <strong>时间复杂度：</strong> O(n) - 需要扫描整个区间<br>
     * <strong>空间复杂度：</strong> O(1) - 仅使用常数额外空间
     * </p>
     *
     * @param arr 待分区的数组
     * @param begin 分区区间的起始索引（包含）
     * @param end 分区区间的结束索引（包含）
     * @return pivot元素的最终位置索引
     */
    static int partitionHoare(int[] arr, int begin, int end) {
        if (begin == end) {
            return begin;
        }

        // 先选左边作为基准，这个位置会影响第一个i
        int pivotal = arr[begin];

        int i = begin;
        int j = end;

        // 哨兵划分 partition() 的最后一步是交换 nums[left] 和 nums[i] 。完成交换后，基准数左边的元素都 <= 基准数，这就要求最后一步交换前 nums[left] >= nums[i]
        // 必须成立。假设我们先"从左往右查找"，那么如果找不到比基准数更大的元素，则会在 i == j 时跳出循环，此时可能 nums[j] == nums[i] >
        // nums[left]。也就是说，此时最后一步交换操作会把一个比基准数更大的元素交换至数组最左端，导致哨兵划分失败。

        // 假设我们选了左边作为基准，则先从右边开始选区间
        while (i < j) {
            // 维持本区间性质，j继续移动。=号是必须的，这样才能恰好找到必须交换的值，排除等号的值
            while (i < j && arr[j] >= pivotal) { // 易错的点：在区间 while 内继续 while 是需要把父条件拷贝进来的
                j--;
            }
            // 维持本区间性质，i继续移动
            while (i < j && arr[i] <= pivotal) { // 易错的点：在区间 while 内继续 while 是需要把父条件拷贝进来的
                i++;
            }
            swap(arr, i, j);
        }
        swap(arr, begin, i);

        return i;
    }

    /**
     * 基于三数取中法的Hoare分区方案
     * <p>
     * 该分区方法结合了三数取中法和Hoare分区的优势，
     * 既避免了最坏情况，又减少了交换次数，是性能最优的分区方案。
     * </p>
     *
     * <p>
     * <strong>算法步骤：</strong>
     * </p>
     * <ol>
     *   <li>使用三数取中法选择pivot，避免最坏情况</li>
     *   <li>将pivot交换到区间起始位置</li>
     *   <li>使用Hoare双指针方案进行分区</li>
     *   <li>最后将pivot交换到最终位置</li>
     * </ol>
     *
     * <p>
     * <strong>分区完成后满足：</strong>
     * </p>
     * <ul>
     *   <li>pivot左边的所有元素 <= pivot</li>
     *   <li>pivot右边的所有元素 >= pivot</li>
     *   <li>pivot位于其最终排序位置</li>
     * </ul>
     *
     * @param arr 待分区的数组
     * @param begin 分区区间的起始索引（包含）
     * @param end 分区区间的结束索引（包含）
     * @return pivot的最终位置索引
     */
    static int partitionMedianOfThree(int[] arr, int begin, int end) {
        if (begin >= end) {
            return begin;
        }

        int mid = begin + (end - begin) / 2;
        final int median = medianOfThree(arr, begin, mid, end);

        // 标准的左交换方案：即使是使用随机化的 pivotal，找到以后都要和开头交换
        int target = arr[median];
        swap(arr, median, begin);
        int l = begin;
        int r = end;

        // 如果l和r相遇了，那么不要循环了
        while (l < r) {
            // 根据 hoare partition 的逻辑，pivot放在开头，就先从右边开始找起

            // 这样可以保证在最后一个循环的时候：
            // 1. 如果r走向l，导致 l == r，而 l 不会向右走。因为此时 l 仍然是上一轮结束的时候交换的结果，所以l必然小于等于target，这样最终与begin交换就可以保证begin的位置仍然小于等于
            // target 的。
            // 2. 如果l走向r，而r不走，那么r保持交换以前的性质，r 大于等于 target
            while (l < r && arr[r] >= target) {
                r--;
            }
            while (l < r && arr[l] <= target) {
                l++;
            }
            swap(arr, l, r);
        }

        // 退出以后，l==r，此时将pivot交换到最终位置，交换前 arr[l]必定小于等于 target
        swap(arr, begin, l);
        return l;
    }

    /**
     * 交换数组中两个位置的元素
     *
     * @param array 目标数组
     * @param i 第一个位置
     * @param j 第二个位置
     */
    private static void swap(int[] array, int i, int j) {
        if (i == j) {
            return;
        }
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }

    /**
     * 三数取中法：找到三个位置中中位数的索引
     * <p>
     * 用于快速排序中选择更好的pivot，避免最坏情况。
     * 通过比较首、中、尾三个位置的元素值，选择中位数作为pivot，
     * 可以有效避免在已排序或逆序数组上的最坏情况。
     * </p>
     *
     * <p>
     * <strong>算法优势：</strong>
     * </p>
     * <ul>
     *   <li>避免最坏情况：对于已排序或逆序数组表现优异</li>
     *   <li>提高平均性能：选择更接近真实中位数的pivot</li>
     *   <li>实现简单：仅需要常数时间的比较操作</li>
     * </ul>
     *
     * @param nums 数组
     * @param left 左索引
     * @param mid 中间索引
     * @param right 右索引
     * @return 中位数所在的索引
     */
    static int medianOfThree(int[] nums, int left, int mid, int right) {
        int a = nums[left];
        int b = nums[mid];
        int c = nums[right];

        // 找出中位数对应的索引，这种中位数的比对方法是唯一正确的，尝试简化if语句都会出错
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return left;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return mid;
        } else {
            return right;
        }
    }

}