# 多数元素问题完整解决方案

## 问题描述

给定一个大小为 n 的数组 nums，返回其中的多数元素。多数元素是指在数组中出现次数大于 ⌊n/2⌋ 的元素。

## 算法总览

### 🎯 记忆口诀大全

- **分治法**："分治递归树高log，每层统计复杂度n，总体nlogn要记牢"
- **Boyer-Moore**："投票算法最优雅，一次遍历O(n)佳，空间常数无可挑"
- **随机化**："随机选择碰运气，期望常数很神奇，概率分析要仔细"
- **哈希表**："哈希统计最直观，空间换时间很划算，O(n)复杂度要记全"
- **排序法**："排序中位必多数，nlogn时间要付出，简单粗暴最好懂"

## 算法详解

### 1. 分治法 (Divide and Conquer)

#### 算法思想

```
分解 → 递归求解 → 合并
```

#### 核心原理

如果一个元素在整个数组中是多数元素（出现次数 > n/2），那么它在左半部分或右半部分中至少有一个子数组中也是多数元素。

#### 复杂度分析

- **时间复杂度**: O(n log n)
    - 递归关系：T(n) = 2T(n/2) + O(n)
    - 主定理：a=2, b=2, f(n)=O(n)，得 T(n) = Θ(n log n)
- **空间复杂度**: O(log n) - 递归调用栈

#### 递归树分析

```
                    T(n)           ← 第0层：O(n)
                   /    \
               T(n/2)  T(n/2)      ← 第1层：O(n)
               /  \    /  \
           T(n/4) ... ... T(n/4)   ← 第2层：O(n)
           ...                     ← ...
           T(1) T(1) ... T(1)      ← 第log n层：O(n)
```

### 2. Boyer-Moore 投票算法 ⭐ (推荐)

#### 算法思想

维护候选元素和计数器，通过"投票"机制找出多数元素。

#### 核心原理

多数元素的出现次数 > n/2，其他所有元素的出现次数之和 < n/2，因此多数元素在"投票"过程中一定能够胜出。

#### 数学证明

设多数元素为 x，出现次数为 k > n/2

- 其他元素总出现次数为 n-k < n/2
- 在最坏情况下，x 的每次出现都被其他元素抵消一次
- 但由于 k > n-k，最终 x 一定会剩余 k-(n-k) = 2k-n > 0 次

#### 复杂度分析

- **时间复杂度**: O(n) - 只需一次遍历
- **空间复杂度**: O(1) - 只使用常数额外空间

#### 算法步骤

```java
1. 初始化候选元素 candidate 和计数器 count
2. 遍历数组：
   - 如果当前元素 == candidate，count++
   - 否则 count--
   - 如果 count == 0，更新 candidate 为当前元素，count = 1
3. 返回 candidate
```

### 3. 随机化算法 (Randomized Algorithm)

#### 算法思想

随机选择数组中的元素，统计其出现次数，如果是多数元素则返回。

#### 概率分析

- 多数元素占数组比例 > 1/2
- 每次随机选择，有超过 1/2 的概率选中多数元素
- 期望尝试次数 < 2 次

#### 数学证明

设多数元素出现次数为 k，数组长度为 n，则 k > n/2

- 随机选择一个元素，选中多数元素的概率 P = k/n > 1/2
- 期望尝试次数 E = 1/P < 1/(1/2) = 2
- 因此期望时间复杂度为 O(n)

#### 复杂度分析

- **时间复杂度**: 期望 O(n)，最坏 O(∞)
- **空间复杂度**: O(1)

### 4. 哈希表统计法

#### 算法思想

使用哈希表统计每个元素的出现次数，返回出现次数 > n/2 的元素。

#### 复杂度分析

- **时间复杂度**: O(n)
- **空间复杂度**: O(n)

### 5. 排序法

#### 算法思想

将数组排序后，多数元素一定会占据中间位置 nums[n/2]。

#### 数学原理

多数元素出现次数 > n/2，排序后必然包含中位数位置。

#### 复杂度分析

- **时间复杂度**: O(n log n)
- **空间复杂度**: O(1) 或 O(n)，取决于排序算法

## 算法对比

| 算法              | 时间复杂度      | 空间复杂度    | 优点           | 缺点        | 推荐指数  |
|-----------------|------------|----------|--------------|-----------|-------|
| **Boyer-Moore** | O(n)       | O(1)     | 最优时空复杂度，一次遍历 | 理解稍复杂     | ⭐⭐⭐⭐⭐ |
| 哈希表             | O(n)       | O(n)     | 直观易懂，适用性广    | 需要额外空间    | ⭐⭐⭐⭐  |
| 随机化             | 期望O(n)     | O(1)     | 期望性能好，空间省    | 最坏情况差，不稳定 | ⭐⭐⭐   |
| 排序法             | O(n log n) | O(1)     | 简单直接，易实现     | 时间复杂度较高   | ⭐⭐    |
| 分治法             | O(n log n) | O(log n) | 教学价值高，思路清晰   | 效率不是最优    | ⭐⭐    |

## 实际应用建议

### 🏆 首选：Boyer-Moore 投票算法

- **适用场景**：所有情况
- **优势**：时间和空间复杂度都是最优
- **记忆要点**：候选人投票，票数归零换人

### 🥈 备选：哈希表统计法

- **适用场景**：需要统计所有元素频次的场景
- **优势**：直观易懂，扩展性好
- **记忆要点**：空间换时间，统计要全面

### 🥉 特殊：随机化算法

- **适用场景**：对稳定性要求不高的场景
- **优势**：期望性能好，实现简单
- **记忆要点**：运气好时很快，运气差时很慢

## 面试要点

### 必须掌握

1. **Boyer-Moore 投票算法**的原理和实现
2. 能够分析各算法的时间空间复杂度
3. 理解分治法的递归树分析

### 加分项

1. 能够证明 Boyer-Moore 算法的正确性
2. 了解随机化算法的概率分析
3. 能够根据具体场景选择合适的算法

### 常见面试问题

1. **Q**: 为什么 Boyer-Moore 算法是正确的？
   **A**: 多数元素出现次数 > n/2，在投票过程中即使每次都被抵消，最终也会剩余正数票数。

2. **Q**: 如果不保证存在多数元素怎么办？
   **A**: Boyer-Moore 算法需要增加验证阶段，再次遍历确认候选元素的出现次数。

3. **Q**: 分治法的时间复杂度为什么是 O(n log n)？
   **A**: 递归树高度 log n，每层需要 O(n) 时间统计，总计 O(n log n)。

## 扩展思考

### 变种问题

1. **多数元素 II**：找出所有出现次数 > n/3 的元素
2. **多数元素 III**：找出所有出现次数 > n/k 的元素

### 优化思路

1. **分治法优化**：只在子范围内统计，而不是整个数组
2. **Boyer-Moore 扩展**：可以扩展到寻找出现次数 > n/k 的元素

## 总结

多数元素问题是一个经典的算法问题，展示了从暴力解法到最优解法的演进过程：

1. **暴力法** → **哈希表** → **排序法** → **分治法** → **Boyer-Moore**
2. 每种算法都有其适用场景和教学价值
3. **Boyer-Moore 投票算法**是最优解，必须熟练掌握
4. 理解算法背后的数学原理比记住代码更重要

记住口诀，理解原理，灵活应用！🚀