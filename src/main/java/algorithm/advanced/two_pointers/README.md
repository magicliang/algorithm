# 双指针算法专题

双指针算法是一种高效的算法技巧，通过使用两个指针在数据结构中移动来解决问题。根据指针的移动方式和策略，可以分为多种类型。

## 算法分类

### 1. 对撞指针（Two Pointers）

两个指针从数组两端开始，向中间移动，直到相遇。

**适用场景：**

- 有序数组中寻找两数之和
- 容器盛水问题
- 回文字符串判断

**移动策略：**

- 根据条件判断移动左指针还是右指针
- 通常基于某种贪心策略

### 2. 快慢指针（Fast-Slow Pointers）

两个指针以不同速度移动，通常用于链表问题。

**适用场景：**

- 检测链表环
- 寻找链表中点
- 寻找倒数第k个节点

**移动策略：**

- 慢指针每次移动1步
- 快指针每次移动2步（或更多）

### 3. 滑动窗口（Sliding Window）

维护一个窗口，通过移动窗口边界来解决问题。

**适用场景：**

- 最长无重复字符子串
- 最小覆盖子串
- 固定长度子数组的最大值

**移动策略：**

- 扩展右边界直到满足条件
- 收缩左边界优化结果

### 4. 分离双指针（Separate Pointers）

两个指针分别处理不同的数组或数据结构。

**适用场景：**

- 合并两个有序数组
- 两个数组的交集
- 比较两个字符串

**移动策略：**

- 根据比较结果移动相应指针

## 双指针移动策略详解

### 1. 固定步长移动

```java
// 每次移动固定步数
left++;
right--;
```

### 2. 条件驱动移动

```java
// 根据条件决定移动哪个指针
if (condition) {
    left++;
} else {
    right--;
}
```

### 3. 跳跃式移动

```java
// 跳过重复元素或满足特定条件的元素
while (left < right && nums[left] == nums[left + 1]) {
    left++;
}
```

### 4. 快慢指针移动

```java
// 不同速度移动
slow = slow.next;
fast = fast.next.next;
```

### 5. 滑动窗口移动

```java
// 动态调整窗口大小
while (right < n) {
    // 扩展右边界
    right++;
    while (needShrink) {
        // 收缩左边界
        left++;
    }
}
```

### 6. 基于差值的移动

```java
// 根据目标值和当前值的差异决定移动方向
int diff = current - target;
if (diff < 0) {
    left++;
} else {
    right--;
}
```

## 时间复杂度分析

大多数双指针算法的时间复杂度为 **O(n)**，因为每个元素最多被访问常数次。

## 空间复杂度分析

双指针算法通常只需要 **O(1)** 的额外空间，是一种空间效率很高的算法技巧。

## 选择合适的双指针策略

选择双指针移动策略时需要考虑：

1. **问题的数学性质**：单调性、有序性等
2. **优化目标**：最大值、最小值、特定条件
3. **约束条件**：去重、范围限制等
4. **数据结构特性**：数组、链表、字符串等

## 实现示例

本包包含以下双指针算法的实现：

1. `TwoSumSorted` - 有序数组两数之和
2. `FastSlowPointers` - 快慢指针示例
3. `SlidingWindow` - 滑动窗口示例
4. `ThreeSum` - 三数之和（跳跃式移动）
5. `ClosestThreeSum` - 最接近的三数之和
6. `MergeTwoArrays` - 合并两个有序数组

每个实现都配有详细的注释和对应的测试用例。