# 贪心算法 (Greedy Algorithm)

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法策略。

## 特点
- **局部最优选择**: 每一步都做出当前看起来最好的选择。
- **无后效性**: 之前的选择不会影响未来的选择，且一旦做出选择，就不能更改。

## 适用场景
贪心算法通常适用于以下问题：
- 存在最优子结构：问题的最优解包含其子问题的最优解。
- 具有贪心选择性质：局部最优解可以导致全局最优解。

## 常见应用
- 霍夫曼编码 (Huffman Coding)
- 最小生成树算法 (Prim's, Kruskal's)
- 单源最短路径算法 (Dijkstra's)
- 找零问题
- 背包问题 (部分背包问题)

## 贪心算法与动态规划的本质区别

### 传统定义的局限性

**传统定义**：
- **动态规划**：根据之前阶段的所有决策来考虑当前决策，使用过去子问题的解来构建当前子问题的解
- **贪心算法**：不考虑过去的决策，一路向前地进行贪心选择，不断缩小问题范围

**传统定义的问题**：
两种算法在当前选择时都使用min/max来考虑可选决策，这让传统定义显得不够精确。

### 真正的本质区别

#### 1. 决策可逆性（核心区别）

| 算法类型 | 决策特性 | 子问题处理 | 最优性保证 |
|---------|---------|------------|------------|
| **动态规划** | **决策可逆** | 保留并比较所有可能的决策路径 | 通过穷举所有可能保证最优 |
| **贪心算法** | **决策不可逆** | 做出选择后不可更改，进入独立子问题 | 依赖贪心选择性质（需数学证明） |

#### 2. 子问题重叠性

**因果关系链**：
```
贪心选择性质 → 决策不可逆 → 子问题不重叠 → 无需缓存技术 → 低空间复杂度
最优子结构 → 需要比较选择 → 子问题重叠 → 需要缓存技术 → 高空间复杂度
```

**关键洞察**：
- **贪心算法**：每次选择后进入**全新的、更小的问题**，这个新问题与之前遇到的任何问题都不相同
- **动态规划**：不同的选择路径可能导向**相同的子问题**，因此需要缓存避免重复计算

#### 3. 空间复杂度差异

| 算法类型 | 典型空间复杂度 | 原因 | 示例 |
|---------|---------------|------|------|
| **贪心算法** | O(1) ~ O(n) | 不需要历史信息，不需要缓存 | 活动选择、霍夫曼编码 |
| **动态规划** | O(n) ~ O(n²) | 需要存储所有子问题的解 | 背包问题、最长公共子序列 |

#### 4. 实际例子对比

**零钱兑换问题**：

```java
// 贪心方法（仅适用于特定硬币系统）
public int coinChangeGreedy(int[] coins, int amount) {
    Arrays.sort(coins, Collections.reverseOrder());
    int count = 0;
    
    for (int coin : coins) {
        while (amount >= coin) {
            amount -= coin;
            count++;
            // 每次决策后进入新的独立子问题，不会重复
        }
    }
    return amount == 0 ? count : -1;
}
// 空间复杂度：O(1)

// DP方法（通用解法）
public int coinChangeDP(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (i >= coin) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                // 需要存储所有子问题的解
            }
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
// 空间复杂度：O(amount)
```

### 更精确的定义

**贪心算法的本质**：
> 通过**贪心选择性质**保证每个局部最优选择都是正确的，因此不需要保留其他选择的信息

**动态规划的本质**：
> 通过**穷举所有可能**来找到最优解，因此必须保存所有子问题的解以避免重复计算

### 核心洞察

**关键区别不在于min/max的使用，而在于**：
1. **决策的可逆性**：贪心算法的决策一旦做出就不可更改
2. **子问题的独立性**：贪心算法的子问题相互独立，不会重复出现
3. **最优性的保证方式**：贪心依赖数学证明，DP依赖穷举比较

**记忆口诀**：
> **"贪心一路向前，不留后路不重叠"**  
> **"动态需要回望，缓存避免重计算"**

## 贪心算法的证明方法

### 实现容易，证明困难

**核心特点**：
- **实现容易**：贪心算法的逻辑直观，代码简洁，无需复杂的状态管理
- **证明困难**：需要严格的数学论证来证明贪心选择性质，通常比实现算法本身更具挑战性

**证明困难的原因**：
- 必须证明**局部最优能导致全局最优**，这需要严格的数学推理
- 需要考虑所有可能的情况和边界条件
- 通常需要用到反证法、数学归纳法等高级证明技巧

### 反证法证明的通用结构

**贪心算法证明的标准五步法**：

1. **假设存在一个最优解S*，它与贪心解S不同**
2. **找到S*中第一个与贪心选择不同的决策点**
3. **证明可以将S*中的这个决策替换为贪心选择，得到S'**
4. **证明S'的目标函数值不劣于S***
5. **重复此过程，最终得到贪心解也是最优解**

### 活动选择问题的证明示例

**问题**：给定n个活动，每个活动有开始时间和结束时间，选择最多的互不冲突的活动。

**贪心策略**：总是选择结束时间最早的活动。

**反证法证明**：

**假设存在最优解O，它选择的第一个活动a₁不是最早结束的活动g₁**

**证明过程**：
- 将O中的a₁替换为g₁，得到新解O'
- 因为g₁结束时间 ≤ a₁结束时间，所以O'仍然可行
- O'的活动数量 = O的活动数量，所以O'也是最优解
- 这说明贪心选择g₁不会影响最优性

**关键洞察**：通过替换操作，我们证明了贪心选择至少不会让情况变坏，而且可以逐步将任意最优解转换为贪心解。

### 反证法的优势

**为什么反证法特别适合贪心算法证明**：

1. **构造性证明**：通过具体的替换操作，展示如何从任意最优解得到贪心解
2. **逐步逼近**：每次替换都让解更接近贪心解，最终收敛
3. **直观性强**：替换操作通常有明确的几何或逻辑意义

### 实际开发中的建议

**不同场景的要求**：

| 场景 | 证明要求 | 实践建议 |
|------|---------|----------|
| **竞赛编程** | 通常不需要严格证明 | 基于经验和直觉快速实现 |
| **学术研究** | 需要完整的数学证明 | 使用反证法等严格方法 |
| **工程实践** | 需要验证正确性 | 通过测试用例和边界情况验证 |

**记忆口诀**：
> **"贪心好写难证明，反证替换是关键"**  
> **"局部最优变全局，数学证明不可少"**

## 注意事项
贪心算法并非适用于所有问题。在某些情况下，局部最优解可能无法导致全局最优解。因此，在使用贪心算法时，需要仔细验证其贪心选择性质。