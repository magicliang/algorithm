# 贪心算法 (Greedy Algorithm)

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法策略。

## 特点

- **局部最优选择**: 每一步都做出当前看起来最好的选择。
- **无后效性**: 之前的选择不会影响未来的选择，且一旦做出选择，就不能更改。

## 适用场景

贪心算法通常适用于以下问题：

- 存在最优子结构：问题的最优解包含其子问题的最优解。
- 具有贪心选择性质：局部最优解可以导致全局最优解。

## 常见应用

- 霍夫曼编码 (Huffman Coding)
- 最小生成树算法 (Prim's, Kruskal's)
- 单源最短路径算法 (Dijkstra's)
- 找零问题
- 背包问题 (部分背包问题)

## 贪心算法与动态规划的本质区别

### 传统定义的局限性

**传统定义**：

- **动态规划**：根据之前阶段的所有决策来考虑当前决策，使用过去子问题的解来构建当前子问题的解
- **贪心算法**：不考虑过去的决策，一路向前地进行贪心选择，不断缩小问题范围

**传统定义的问题**：
两种算法在当前选择时都使用min/max来考虑可选决策，这让传统定义显得不够精确。

### 真正的本质区别

#### 1. 决策可逆性（核心区别）

| 算法类型     | 决策特性      | 子问题处理             | 最优性保证           |
|----------|-----------|-------------------|-----------------|
| **动态规划** | **决策可逆**  | 保留并比较所有可能的决策路径    | 通过穷举所有可能保证最优    |
| **贪心算法** | **决策不可逆** | 做出选择后不可更改，进入独立子问题 | 依赖贪心选择性质（需数学证明） |

#### 2. 子问题重叠性

**因果关系链**：

```
贪心选择性质 → 决策不可逆 → 子问题不重叠 → 无需缓存技术 → 低空间复杂度
最优子结构 → 需要比较选择 → 子问题重叠 → 需要缓存技术 → 高空间复杂度
```

**关键洞察**：

- **贪心算法**：每次选择后进入**全新的、更小的问题**，这个新问题与之前遇到的任何问题都不相同
- **动态规划**：不同的选择路径可能导向**相同的子问题**，因此需要缓存避免重复计算

#### 3. 空间复杂度差异

| 算法类型     | 典型空间复杂度      | 原因            | 示例           |
|----------|--------------|---------------|--------------|
| **贪心算法** | O(1) ~ O(n)  | 不需要历史信息，不需要缓存 | 活动选择、霍夫曼编码   |
| **动态规划** | O(n) ~ O(n²) | 需要存储所有子问题的解   | 背包问题、最长公共子序列 |

#### 4. 实际例子对比

**零钱兑换问题**：

```java
// 贪心方法（仅适用于特定硬币系统）
public int coinChangeGreedy(int[] coins, int amount) {
    Arrays.sort(coins, Collections.reverseOrder());
    int count = 0;

    for (int coin : coins) {
        while (amount >= coin) {
            amount -= coin;
            count++;
            // 每次决策后进入新的独立子问题，不会重复
        }
    }
    return amount == 0 ? count : -1;
}
// 空间复杂度：O(1)

// DP方法（通用解法）
public int coinChangeDP(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;

    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (i >= coin) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                // 需要存储所有子问题的解
            }
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
// 空间复杂度：O(amount)
```

### 更精确的定义

**贪心算法的本质**：
> 通过**贪心选择性质**保证每个局部最优选择都是正确的，因此不需要保留其他选择的信息

**动态规划的本质**：
> 通过**穷举所有可能**来找到最优解，因此必须保存所有子问题的解以避免重复计算

### 核心洞察

**关键区别不在于min/max的使用，而在于**：

1. **决策的可逆性**：贪心算法的决策一旦做出就不可更改
2. **子问题的独立性**：贪心算法的子问题相互独立，不会重复出现
3. **最优性的保证方式**：贪心依赖数学证明，DP依赖穷举比较

**记忆口诀**：
> **"贪心一路向前，不留后路不重叠"**  
> **"动态需要回望，缓存避免重计算"**

## 贪心算法的证明方法

### 实现容易，证明困难

**核心特点**：

- **实现容易**：贪心算法的逻辑直观，代码简洁，无需复杂的状态管理
- **证明困难**：需要严格的数学论证来证明贪心选择性质，通常比实现算法本身更具挑战性

**证明困难的原因**：

- 必须证明**局部最优能导致全局最优**，这需要严格的数学推理
- 需要考虑所有可能的情况和边界条件
- 通常需要用到反证法、数学归纳法等高级证明技巧

### 反证法证明的通用结构

**贪心算法证明的标准五步法**：

1. **假设存在一个最优解S*，它与贪心解S不同**
2. **找到S*中第一个与贪心选择不同的决策点**
3. **证明可以将S*中的这个决策替换为贪心选择，得到S'**
4. **证明S'的目标函数值不劣于S***
5. **重复此过程，最终得到贪心解也是最优解**

### 活动选择问题的证明示例

**问题**：给定n个活动，每个活动有开始时间和结束时间，选择最多的互不冲突的活动。

**贪心策略**：总是选择结束时间最早的活动。

**反证法证明**：

**假设存在最优解O，它选择的第一个活动a₁不是最早结束的活动g₁**

**证明过程**：

- 将O中的a₁替换为g₁，得到新解O'
- 因为g₁结束时间 ≤ a₁结束时间，所以O'仍然可行
- O'的活动数量 = O的活动数量，所以O'也是最优解
- 这说明贪心选择g₁不会影响最优性

**关键洞察**：通过替换操作，我们证明了贪心选择至少不会让情况变坏，而且可以逐步将任意最优解转换为贪心解。

### 反证法的优势

**为什么反证法特别适合贪心算法证明**：

1. **构造性证明**：通过具体的替换操作，展示如何从任意最优解得到贪心解
2. **逐步逼近**：每次替换都让解更接近贪心解，最终收敛
3. **直观性强**：替换操作通常有明确的几何或逻辑意义

### 实际开发中的建议

**不同场景的要求**：

| 场景       | 证明要求      | 实践建议          |
|----------|-----------|---------------|
| **竞赛编程** | 通常不需要严格证明 | 基于经验和直觉快速实现   |
| **学术研究** | 需要完整的数学证明 | 使用反证法等严格方法    |
| **工程实践** | 需要验证正确性   | 通过测试用例和边界情况验证 |

**记忆口诀**：
> **"贪心好写难证明，反证替换是关键"**  
> **"局部最优变全局，数学证明不可少"**

## 贪心算法与动态规划的理论关系

### 核心理论认知

#### 1. 算法包含关系

- **贪心 ≠ DP的特例**：两者有本质区别（决策可逆性、子问题重叠性）
- **贪心问题 ⊆ DP问题**：所有贪心问题都可以用DP解决（但效率可能更低）

**理论基础**：

- 贪心问题必须满足**最优子结构**性质
- 有最优子结构的问题都可以用DP求解
- DP通过穷举所有可能来保证最优性，是更通用的方法

#### 2. 效率对比

| 算法类型     | 时间复杂度             | 空间复杂度      | 适用条件     | 最优性保证  |
|----------|-------------------|------------|----------|--------|
| **贪心算法** | 通常O(n)~O(n log n) | O(1)~O(n)  | 需要贪心选择性质 | 依赖数学证明 |
| **动态规划** | 通常O(n²)~O(n³)     | O(n)~O(n²) | 需要最优子结构  | 通过穷举保证 |

**关键洞察**：
> **"贪心是DP的高效特例，但需要严格的数学证明"**

## 硬币兑换问题的贪心适用性

### 规范币制的简化定义

**规范币制（Canonical Coin System）**：
> 一个硬币系统是规范的，当且仅当**贪心算法总是能得到最优解**。

#### 直观理解

**核心特征**：除了最小单位（通常是1），其他面额都是前面某个面额的整数倍关系。

**简单判断规则**：

- ✅ **规范币制**：面额之间有良好的倍数关系，贪心算法有效
- ❌ **非规范币制**：面额之间缺乏合理的倍数关系，贪心算法失效

#### 规范币制的倍数关系深度分析

**核心问题**：什么样的倍数关系能保证贪心算法的最优性？

##### 1. 经典倍数模式分析

| 倍数类型       | 示例系统              | 数学特征          | 贪心有效性  |
|------------|-------------------|---------------|--------|
| **纯倍数系统**  | [1, 2, 4, 8, 16]  | 每个面额都是前一个的整数倍 | ✅ 完全有效 |
| **混合倍数系统** | [1, 2, 5, 10, 20] | 包含2倍和5倍关系     | ✅ 有效   |
| **部分倍数系统** | [1, 3, 9, 27]     | 3的幂次系列        | ✅ 有效   |
| **破坏性系统**  | [1, 3, 4]         | 缺乏良好覆盖关系      | ❌ 无效   |

##### 2. 允许的倍数关系扩展

**不仅限于1、2、5倍**！以下倍数关系都可能构成规范币制：

```java
// 3倍系统 - 完全有效
int[] coins1 = {1, 3, 9, 27, 81};  // 3^n 系列

// 混合倍数系统 - 有效
int[] coins2 = {1, 2, 6, 12, 60};  // 包含6倍关系

// 4倍系统 - 有效  
int[] coins3 = {1, 4, 16, 64};     // 4^n 系列

// 复杂但有效的系统
int[] coins4 = {1, 3, 7, 21};      // 3倍和7倍的组合
```

##### 3. 倍数关系的数学原理

**关键洞察**：规范性不依赖于特定的倍数值，而依赖于**覆盖性质**。

**覆盖性质定义**：
> 对于任意金额n，如果存在面额c使得贪心选择c后，剩余金额n-c的最优解加上1等于n的最优解，则该系统满足覆盖性质。

**数学表达**：

```
∀n, ∃c ∈ coins: OPT(n) = OPT(n-c) + 1
其中c是贪心算法对金额n的选择
```

##### 4. 非传统倍数的成功案例

**案例1：斐波那契币制**

```java
int[] fibCoins = {1, 2, 3, 5, 8, 13, 21};  // 斐波那契数列
// 这个系统是规范的！因为每个数都能被前面的数良好覆盖
```

**案例2：质数币制**

```java
int[] primeCoins = {1, 2, 3, 5, 7, 11};    // 质数序列
// 在特定条件下可能是规范的
```

##### 5. 倍数关系失效的临界条件

**失效模式分析**：

```java
// 失效案例1：跳跃过大
int[] badCoins1 = {1, 3, 4};
// 问题：3和4之间缺乏良好的倍数关系，导致金额6时贪心失效

// 失效案例2：覆盖不足
int[] badCoins2 = {1, 5, 6};
// 问题：对于金额8，贪心选择6+1+1=3个，但5+1+1+1=4个更差，实际最优是无解

// 成功案例：良好覆盖
int[] goodCoins = {1, 3, 4, 12};
// 虽然包含{1,3,4}，但12的加入可能修复了覆盖问题
```

##### 6. 倍数关系的设计原则

**设计规范币制的经验法则**：

1. **渐进增长**：相邻面额的比值不应过大
   ```java
   // 好的设计
   [1, 2, 5, 10, 20, 50]  // 比值：2, 2.5, 2, 2, 2.5
   
   // 危险的设计  
   [1, 2, 10, 11]         // 比值：2, 5, 1.1 - 跳跃过大
   ```

2. **覆盖完整性**：大面额应该能够"回退"到小面额的组合
   ```java
   // 覆盖完整的例子
   [1, 3, 9]  // 9可以分解为3+3+3，3可以分解为1+1+1
   ```

3. **避免"陷阱区间"**：不应存在某个金额区间，使得贪心选择明显劣于其他组合

**更直观的判定方法**：

**经验规则**：如果硬币系统中较大面额能够"很好地覆盖"较小面额的组合，通常就是规范的。

**反例特征**：当存在某个金额，用较小面额的组合比贪心选择更优时，就不是规范币制。

#### 常见的规范币制示例

| 币制系统      | 面额集合                            | 规范性   | 说明       |
|-----------|---------------------------------|-------|----------|
| **美元系统**  | [1, 5, 10, 25, 50, 100]         | ✅ 规范  | 经典规范币制   |
| **欧元系统**  | [1, 2, 5, 10, 20, 50, 100, 200] | ✅ 规范  | 包含2的规范币制 |
| **人民币系统** | [1, 2, 5, 10, 20, 50, 100]      | ✅ 规范  | 实际货币系统   |
| **反例系统**  | [1, 3, 4]                       | ❌ 非规范 | 经典反例     |

#### 非规范币制的经典反例

**币制**：C = {1, 3, 4}，**目标金额**：6

```java
// 贪心算法路径
6 →选4 → 2 →选1 → 1 →选1 → 0    // 结果：3个硬币 [4,1,1]

// 最优解路径  
        6 →选3 → 3 →选3 → 0              // 结果：2个硬币 [3,3]
```

**数学分析**：

- 贪心解：`GREEDY({1,3,4}, 6) = 3`
- 最优解：`OPT({1,3,4}, 6) = 2`
- 因为 `3 ≠ 2`，所以 {1,3,4} 不是规范币制

#### 规范币制的重要性质

1. **贪心最优性**：规范币制保证贪心算法的全局最优性
2. **计算效率**：贪心算法时间复杂度O(k)，DP算法时间复杂度O(nk)
3. **实用价值**：现实中的货币系统通常都是规范币制

### 硬币兑换问题的算法选择策略

```java
/**
 * 硬币兑换问题的算法选择指南
 */
public class CoinChangeStrategy {

    /**
     * 规范币制 - 使用贪心算法
     * 时间复杂度：O(k)，空间复杂度：O(1)
     */
    public int coinChangeGreedy(int[] coins, int amount) {
        // 适用于规范币制，如 [1,5,10,25]
        Arrays.sort(coins, Collections.reverseOrder());
        int count = 0;
        for (int coin : coins) {
            count += amount / coin;
            amount %= coin;
        }
        return amount == 0 ? count : -1;
    }

    /**
     * 非规范币制 - 必须使用动态规划
     * 时间复杂度：O(amount × coins.length)，空间复杂度：O(amount)
     */
    public int coinChangeDP(int[] coins, int amount) {
        // 通用解法，适用于任意币制
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;

        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (i >= coin) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

### 理论总结

#### 核心认知

1. **规范币制 → 贪心可行**：满足特定数学性质的硬币系统可以用贪心算法
2. **非规范币制 → 必须DP**：一般情况下需要动态规划保证最优性
3. **效率权衡**：规范币制下贪心算法效率远高于DP

#### 实践指导

```
判断币制类型 → 选择算法策略
    ↓
规范币制 → 贪心算法（O(k)时间，O(1)空间）
    ↓
非规范币制 → 动态规划（O(nk)时间，O(n)空间）
```

**记忆口诀**：
> **"规范币制贪心行，非规范制DP赢"**  
> **"数学证明是关键，效率最优看条件"**

## 注意事项

贪心算法并非适用于所有问题。在某些情况下，局部最优解可能无法导致全局最优解。因此，在使用贪心算法时，需要仔细验证其贪心选择性质。特别是在硬币兑换等问题中，必须先确认币制的规范性，才能决定是否可以使用贪心算法。