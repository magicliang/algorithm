# 贪心算法 (Greedy Algorithm)

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法策略。

## 特点
- **局部最优选择**: 每一步都做出当前看起来最好的选择。
- **无后效性**: 之前的选择不会影响未来的选择，且一旦做出选择，就不能更改。

## 适用场景
贪心算法通常适用于以下问题：
- 存在最优子结构：问题的最优解包含其子问题的最优解。
- 具有贪心选择性质：局部最优解可以导致全局最优解。

## 常见应用
- 霍夫曼编码 (Huffman Coding)
- 最小生成树算法 (Prim's, Kruskal's)
- 单源最短路径算法 (Dijkstra's)
- 找零问题
- 背包问题 (部分背包问题)

## 贪心算法与动态规划的本质区别

### 传统定义的局限性

**传统定义**：
- **动态规划**：根据之前阶段的所有决策来考虑当前决策，使用过去子问题的解来构建当前子问题的解
- **贪心算法**：不考虑过去的决策，一路向前地进行贪心选择，不断缩小问题范围

**传统定义的问题**：
两种算法在当前选择时都使用min/max来考虑可选决策，这让传统定义显得不够精确。

### 真正的本质区别

#### 1. 决策可逆性（核心区别）

| 算法类型 | 决策特性 | 子问题处理 | 最优性保证 |
|---------|---------|------------|------------|
| **动态规划** | **决策可逆** | 保留并比较所有可能的决策路径 | 通过穷举所有可能保证最优 |
| **贪心算法** | **决策不可逆** | 做出选择后不可更改，进入独立子问题 | 依赖贪心选择性质（需数学证明） |

#### 2. 子问题重叠性

**因果关系链**：
```
贪心选择性质 → 决策不可逆 → 子问题不重叠 → 无需缓存技术 → 低空间复杂度
最优子结构 → 需要比较选择 → 子问题重叠 → 需要缓存技术 → 高空间复杂度
```

**关键洞察**：
- **贪心算法**：每次选择后进入**全新的、更小的问题**，这个新问题与之前遇到的任何问题都不相同
- **动态规划**：不同的选择路径可能导向**相同的子问题**，因此需要缓存避免重复计算

#### 3. 空间复杂度差异

| 算法类型 | 典型空间复杂度 | 原因 | 示例 |
|---------|---------------|------|------|
| **贪心算法** | O(1) ~ O(n) | 不需要历史信息，不需要缓存 | 活动选择、霍夫曼编码 |
| **动态规划** | O(n) ~ O(n²) | 需要存储所有子问题的解 | 背包问题、最长公共子序列 |

#### 4. 实际例子对比

**零钱兑换问题**：

```java
// 贪心方法（仅适用于特定硬币系统）
public int coinChangeGreedy(int[] coins, int amount) {
    Arrays.sort(coins, Collections.reverseOrder());
    int count = 0;
    
    for (int coin : coins) {
        while (amount >= coin) {
            amount -= coin;
            count++;
            // 每次决策后进入新的独立子问题，不会重复
        }
    }
    return amount == 0 ? count : -1;
}
// 空间复杂度：O(1)

// DP方法（通用解法）
public int coinChangeDP(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (i >= coin) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                // 需要存储所有子问题的解
            }
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
// 空间复杂度：O(amount)
```

### 更精确的定义

**贪心算法的本质**：
> 通过**贪心选择性质**保证每个局部最优选择都是正确的，因此不需要保留其他选择的信息

**动态规划的本质**：
> 通过**穷举所有可能**来找到最优解，因此必须保存所有子问题的解以避免重复计算

### 核心洞察

**关键区别不在于min/max的使用，而在于**：
1. **决策的可逆性**：贪心算法的决策一旦做出就不可更改
2. **子问题的独立性**：贪心算法的子问题相互独立，不会重复出现
3. **最优性的保证方式**：贪心依赖数学证明，DP依赖穷举比较

**记忆口诀**：
> **"贪心一路向前，不留后路不重叠"**  
> **"动态需要回望，缓存避免重计算"**

## 注意事项
贪心算法并非适用于所有问题。在某些情况下，局部最优解可能无法导致全局最优解。因此，在使用贪心算法时，需要仔细验证其贪心选择性质。