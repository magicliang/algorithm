# 动态规划完整学习指南

## 第一章：动态规划基础理论

### 1.1 什么是动态规划

动态规划是一种解决复杂问题的算法思想，它将大问题分解为小问题，通过解决小问题来构建大问题的解。

**核心思想**：避免重复计算，用空间换时间。

### 1.2 动态规划的两大核心性质

#### 性质一：最优子结构

**定义**：一个问题的最优解包含其子问题的最优解。

**在代码中的体现**：

```java
// 0-1背包状态转移方程
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
//         ↑不选第i个物品    ↑选第i个物品
//         的最优解          的最优解
```

**关键认知**：整个问题的最优解完全由子问题的最优解组合而成。

#### 性质二：重叠子问题

**定义**：在递归求解过程中，许多子问题会被重复计算。

**证据**：

- 状态空间远小于搜索空间：虽然有2^n种选择组合，但只有`(n+1) × (capacity+1)`个不同的子问题状态
- 记忆化的必要性：如果没有重叠子问题，缓存就没有意义

**优化效果**：从指数级时间复杂度降为多项式级。

### 1.3 从暴力搜索到动态规划的演进

#### 阶段1：暴力搜索（DFS）

- **特点**：构建高度为n的决策树，每层2个选择
- **复杂度**：时间O(2^n)，空间O(n)

**用例子理解2^n**：
假设有3个物品的0-1背包问题，每个物品都有"选"或"不选"两种选择：

```
物品1: 选/不选 (2种选择)
物品2: 选/不选 (2种选择) 
物品3: 选/不选 (2种选择)
总组合数 = 2×2×2 = 2³ = 8种
```

**所有可能组合**：(选选选)、(选选不选)、(选不选选)、(选不选不选)、(不选选选)、(不选选不选)、(不选不选选)、(不选不选不选)

**记忆口诀**：n个物品，每个2选择，总共2^n种组合
**空间O(n)**：递归栈最深n层（每层处理一个物品）

- **问题**：大量重复计算

#### 阶段2：记忆化搜索

- **优化原理**：每个子问题只计算一次
- **复杂度**：时间O(n×capacity)，空间O(n×capacity)
- **本质**：从"有重复组合"到"无重复组合"的关键优化

#### 阶段3：动态规划

- **特点**：自底向上的迭代计算
- **优势**：避免递归栈溢出，更适合生产环境
- **本质**：DP的每个迭代步骤就是在执行DFS在对应状态下的决策逻辑

**核心认知**：三种方法的决策逻辑完全相同，只是计算顺序不同。

## 第二章：状态转移方程的设计：数学归纳法的妙用

动态规划的真正难点，往往不在于理解其思想，而在于如何精确地设计出**状态转移方程**
。这是连接问题定义与代码实现的核心桥梁。一个常见的思维误区是直接陷入细节，试图一步到位写出最终代码。

一个更强大、更符合逻辑的思维工具是**数学归纳法**。

### 2.1 为什么是数学归纳法？

数学归纳法的核心思想与动态规划不谋而合：

1. **基础步骤 (Base Case)**：证明最小规模问题（例如 `n=1`）的解是正确的。这对应DP中的**边界条件初始化**。
2. **归纳假设 (Inductive Hypothesis)**：假设规模为 `k` 的问题已经解决（即 `dp[k]` 或 `dp[k-1]` 是已知的最优解）。
3. **归纳步骤 (Inductive Step)**：证明在假设成立的基础上，可以推导出规模为 `k+1` 的问题的解。这正是**设计状态转移方程**的过程。

### 2.2 使用数学归纳法设计状态转移方程的步骤

让我们以一个简单的问题为例：**爬楼梯**（每次可以爬1阶或2阶，求到达第 `n` 阶的方法数）。

**第一步：定义状态 `dp[i]` 的含义**
`dp[i]` 表示到达第 `i` 阶的总方法数。这是我们的目标。

**第二步：基础步骤 (Base Case)**

- `dp[1] = 1` (到达第1阶只有1种方法：跳1阶)
- `dp[2] = 2` (到达第2阶有2种方法：跳1+1，或跳2)
  这是我们DP的边界。

**第三步：归纳假设 (Inductive Hypothesis)**
假设我们已经知道了如何解决所有规模小于 `n` 的子问题。也就是说，对于任意 `k < n`，`dp[k]` 的值是已知的、正确的。
具体来说，我们假设 `dp[n-1]` 和 `dp[n-2]` 已经计算出来了。

**第四步：归纳步骤 (Inductive Step) - 推导 `dp[n]`**
现在，我们要思考如何利用已知的 `dp[n-1]` 和 `dp[n-2]` 来计算 `dp[n]`。

- **思考最后一跳**：要想到达第 `n` 阶，最后一跳只有两种可能：
    1. 从第 `n-1` 阶跳 `1` 阶上来。
    2. 从第 `n-2` 阶跳 `2` 阶上来。

- **建立联系**：
    - 所有从 `n-1` 阶跳上来的方法数，根据我们的归纳假设，就是 `dp[n-1]`。
    - 所有从 `n-2` 阶跳上来的方法数，根据我们的归纳假设，就是 `dp[n-2]`。

- **合并结果**：
  这两种情况是互斥的（最后一跳不可能既是1阶又是2阶），且包含了所有可能性。因此，总方法数就是两者之和。
  于是，我们推导出了状态转移方程：
  `dp[n] = dp[n-1] + dp[n-2]`

### 2.3 核心洞察

使用数学归纳法思维，你不需要一开始就考虑整个复杂的计算过程。你只需要聚焦于：
> **“假设我已经解决了所有子问题，我如何仅利用这些子问题的解，来构建当前问题的解？”**

这种思维方式将你从繁杂的递归树中解放出来，让你专注于**相邻状态之间的逻辑关系**，从而自然地推导出状态转移方程。

**记忆口诀**：
> **“DP难，想归纳；先假设，后推导。”**
> **“假设子问题已解，思考最后一步该怎么走。”**

## 第三章：动态规划实现模板

### 3.1 普通递归搜索模板

```
1. 定义递归函数和参数（状态表示）
2. 处理单一维度边界条件（递归终止条件）
3. 处理维度相互干涉约束条件（资源不足时的处理）
4. 枚举所有可能的决策选择
5. 递归求解子问题
6. 合并子问题结果，返回最优解
```

### 3.2 记忆化搜索模板

```
1. 基于普通递归搜索
2. 初始化备忘录（关键：避开合法返回值，如用-1避开0）
3. 处理单一维度边界条件（递归终止）
4. 检查缓存：如果本层已计算，直接返回
5. 专门处理维度相互干涉约束条件（如容量不足）
6. 枚举决策，递归求解子问题
7. 合并子问题结果
8. 缓存本层结果并返回
```

**关键认知**：

- **避开合法值**：用-1避开0这个合法返回值
- **每层只处理本层缓存**：不要替子问题做决定

**记忆口诀**：

- **记忆化搜索**：用"不可能值"标记未计算（如-1）
- **动态规划**：用"真实值"初始化边界（如0）

### 3.3 动态规划模板

```
1. 定义状态：dp[i][j]的含义
2. 处理单一维度边界条件和维度相互干涉特殊情况
3. 初始化DP表（关键：使用合法值初始化，如边界状态设为0）
4. 确定状态转移顺序（通常是嵌套循环）
5. 在循环中：
   - 专门处理资源约束条件（如容量不足）
   - 枚举决策选择
   - 应用状态转移方程
   - 更新DP表
6. 返回目标状态的值
```

**关键认知**：

- **使用合法值初始化**：直接用0初始化边界状态
- **DP不做递归**：用循环替代递归，避免栈溢出

### 3.4 二维DP初始化的核心原则

#### 3.4.1 边界初始化三步法

**第一步：语义定含义**
> 根据dp[i][j]的实际含义，推导边界状态的真实意义

**具体操作**：

- **分析dp[0][j]**：当第一个维度为0时，这个状态在现实中代表什么？
- **分析dp[i][0]**：当第二个维度为0时，这个状态在现实中代表什么？
- **分析dp[0][0]**：当两个维度都为0时，这是什么基础情况？

**实例说明**：

```java
// 背包问题：dp[i][j] = 前i个物品，容量j的最大价值
// dp[0][j] 的含义：前0个物品（即没有物品），容量为j的最大价值
// dp[i][0] 的含义：前i个物品，容量为0的最大价值  
// dp[0][0] 的含义：没有物品，容量为0的最大价值
```

**第二步：合法性检查**
> 边界值必须是问题约束下的合法解，不能违反问题的基本规则

**检查标准**：

- **现实可达性**：这个边界状态在现实中是否可能发生？
- **约束兼容性**：这个值是否满足问题的所有约束条件？
- **数值合理性**：这个值是否在问题的合理取值范围内？

**对比示例**：

```java
// 背包问题的合法性检查
dp[0][j] = 0;    // ✅ 合法：没有物品时价值确实为0
dp[i][0] = 0;    // ✅ 合法：容量为0时确实装不下任何东西，价值为0
dp[0][0] = 0;    // ✅ 合法：没有物品且容量为0，价值为0

// 零钱兑换问题的合法性检查  
dp[0][0] = 0;    // ✅ 合法：用0种硬币凑出0元，确实需要0个硬币
dp[0][j] = -1;   // ✅ 合法：用0种硬币凑出正数金额，确实不可能（用-1标记无解）
dp[i][0] = 0;    // ✅ 合法：凑出0元，确实需要0个硬币

// 错误示例
dp[0][j] = Integer.MAX_VALUE;  // ❌ 不合法：没有物品时价值不可能是无穷大
```

**第三步：一致性保证**
> 边界初始化必须与状态转移方程保持一致，不能产生计算冲突

**一致性检查要点**：

- **数值兼容性**：边界值参与max/min运算时不会产生错误结果
- **类型一致性**：边界值的数据类型与状态转移中的计算保持一致
- **逻辑一致性**：边界值的逻辑含义与状态转移的逻辑保持一致

**实例验证**：

```java
// 背包问题状态转移：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)
// 一致性检查：
dp[0][j] = 0;   // ✅ 一致：max(0, other) 不会产生错误
dp[0][j] = -1;  // ❌ 不一致：max(-1, positive) 会被-1干扰

// 最小路径和状态转移：dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
// 一致性检查：
dp[0][0] = grid[0][0];  // ✅ 一致：起点值就是grid[0][0]
dp[0][0] = 0;          // ❌ 不一致：忽略了起点本身的值
```

#### 3.4.2 三大边界的协调关系

**dp[0][0]是基础**：

- **作用**：整个DP表的起始点，所有计算的根源
- **特点**：通常是问题的最简单情况或空集状态
- **重要性**：如果dp[0][0]错误，会影响整个DP表的计算

**dp[0][j]和dp[i][0]是边界**：

- **作用**：为第一行和第一列提供初始值
- **特点**：代表单一维度的极值情况
- **关系**：必须与dp[0][0]在逻辑上保持一致

**三者协调一致的含义**：

```java
// 协调一致的示例（背包问题）
dp[0][0] = 0;  // 基础：没有物品，容量为0，价值为0
dp[0][j] = 0;  // 边界：没有物品，任何容量下价值都为0（与基础一致）
dp[i][0] = 0;  // 边界：任何物品，容量为0时价值都为0（与基础一致）

// 不协调的错误示例
dp[0][0] = 0;   // 基础：没有物品，容量为0，价值为0
dp[0][j] = -1;  // 边界：没有物品，容量>0时价值为-1（与基础逻辑矛盾！）
dp[i][0] = 1;   // 边界：有物品，容量为0时价值为1（与基础逻辑矛盾！）
```

#### 3.4.3 实用的初始化检查清单

**检查清单**：

1. **语义检查**：dp[0][j]、dp[i][0]、dp[0][0]的实际含义是什么？
2. **合法性检查**：这些边界值在问题约束下是否合法？
3. **一致性检查**：边界值是否与状态转移方程兼容？
4. **协调性检查**：三个边界之间是否逻辑一致？
5. **特殊值检查**：是否需要用特殊值标记无解情况？

**调试验证**：

```java
// 初始化后的验证代码
System.out.println("dp[0][0] = " + dp[0][0] + " (基础状态)");
System.out.println("第0行: " + Arrays.toString(dp[0]));
for (int i = 0; i < m; i++) {
    System.out.println("第" + i + "行第0列: " + dp[i][0]);
}
// 检查这些值是否符合问题的实际含义
```

**记忆口诀**：
> **"边界初始化三步走：语义定含义，合法性检查，一致性保证"**
> **"dp[0][0]是基础，dp[0][j]和dp[i][0]是边界，三者必须协调一致"**

## 第四章：状态转移方程的深度理解

### 4.1 为什么选择后的子问题是 `dp[i][j-cost]`？

**数学递推的逻辑**：

- **原问题**：用前i种资源，在约束j下的最优解
- **选择第i种资源后的新问题**：用前i种资源，在约束(j-cost)下的最优解

**关键洞察**：当我们做出选择时，问题规模确实缩小了（我们已经做出了选择），这个缩小后的问题的最优解，就是我们要利用的子问题解。

### 4.2 dp[i] vs dp[i-1] 的核心区别

| 问题类型      | 状态转移              | 含义           | 典型问题      |
|-----------|-------------------|--------------|-----------|
| **无限制重复** | `dp[i][j-cost]`   | 选择后仍可继续使用该资源 | 完全背包、硬币兑换 |
| **一次性选择** | `dp[i-1][j-cost]` | 选择后不能再使用该资源  | 01背包、任务调度 |

**记忆口诀**：
> **"能重复用i，不能重复用i-1"**

### 4.3 状态转移中的运算符选择原则

在动态规划的状态转移方程中，选择合适的运算符（`min`、`max`、`+`等）是关键的一步。

#### 4.3.1 运算符选择的核心原则

**问题目标决定运算符类型**：

| 问题目标     | 运算符           | 典型问题            | 状态转移示例                               |
|----------|---------------|-----------------|--------------------------------------|
| **求最优值** | `min` / `max` | 最少硬币数、最短路径、最大价值 | `dp[i] = min(dp[i], dp[i-coin] + 1)` |
| **求方案数** | `+`           | 组合数、路径数、方法数     | `dp[i] += dp[i-coin]`                |
| **求可行性** | `             |                 | ` (或运算)                              | 是否可达、是否存在 | `dp[i] = dp[i] || dp[i-coin]` |

#### 4.3.2 具体选择原则

**优化问题 → min/max**

- **特征**：寻找"最优解"
- **子问题关系**：竞争关系，需要选择最优的一个

```java
// 零钱兑换I：求最少硬币数
dp[i] = min(dp[i], dp[i-coin] + 1);  // 选择硬币数更少的方案

// 0-1背包：求最大价值
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v);  // 选择价值更大的方案
```

**计数问题 → 加法运算**

- **特征**：统计"方案总数"
- **子问题关系**：累积关系，需要统计所有可能

```java
// 零钱兑换II：求组合数
dp[i] += dp[i-coin];  // 累加所有可能的组合方案

// 不同路径：求路径数
dp[i][j] = dp[i-1][j] + dp[i][j-1];  // 累加从不同方向来的路径数
```

**存在性问题 → 逻辑或运算**

- **特征**：判断"是否可能"
- **子问题关系**：或关系，任一成立即可

```java
// 分割等和子集：是否存在
dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];  // 任一方案可行即为true
```

#### 4.3.3 运算符选择的深层逻辑

**问题语义映射**：

| 问题描述关键词        | 对应运算符 | 语义解释            |
|----------------|-------|-----------------|
| "最少"、"最小"、"最短" | `min` | 在所有可能方案中选择代价最小的 |
| "最多"、"最大"、"最长" | `max` | 在所有可能方案中选择收益最大的 |
| "多少种"、"几种方法"   | `+`   | 统计所有不同的可行方案数量   |
| "能否"、"是否存在"    | `     |                 |` | 只要存在一种可行方案即可 |

#### 4.3.4 实际应用对比

**零钱兑换问题系列**：

```java
// 零钱兑换I：最少硬币数（优化问题）
for (int coin : coins) {
    if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i-coin] + 1);  // min选择
    }
}

// 零钱兑换II：组合数（计数问题）
for (int coin : coins) {
    for (int i = coin; i <= amount; i++) {
        dp[i] += dp[i-coin];  // 加法累计
    }
}
```

#### 4.3.5 核心洞察

**运算符选择的本质**：
> 运算符反映了**子问题解之间的组合逻辑**

**记忆口诀**：
> **"求最优用min/max，求总数用加法"**  
> **"问可行用或运算，看问题定运算"**

**关键认知**：

- **优化问题**：子问题之间是**竞争关系**，需要选择最优的一个
- **计数问题**：子问题之间是**累积关系**，需要统计所有可能
- **存在性问题**：子问题之间是**或关系**，任一成立即可

## 第五章：约束处理的优先级原则

在动态规划问题中，约束条件的处理遵循严格的优先级顺序：

### 5.1 资源约束优先原则（最高优先级）

- **定义**：当资源出现极值时，选择空间受限但DP状态仍然合法
- **处理方式**：强制选择特定路径，DP值继承合法状态
- **关键认知**：资源极值时，状态极值的DP是合法的

### 5.2 状态边界检查原则（次优先级）

- **定义**：当状态出现极值时，可能违反问题的基本约束
- **处理方式**：返回非法标记或边界值
- **关键认知**：状态极值时，DP可能非法

### 5.3 优化选择原则（最低优先级）

- **定义**：在合法范围内选择最优方案
- **处理方式**：使用min/max函数选择最优解

**优先级关系**：

```
资源约束优先原则 > 状态边界检查原则 > 优化选择原则
```

**代码实现体现**：

```java
// 1. 状态边界检查（次优先级）
if (i == 0) {
    return -1;  // 无硬币无法凑出正金额，非法状态
}

// 2. 资源约束检查（最高优先级）
if (coins[i-1] > targetAmount) {
    return subProblemChoice;  // 硬币太大，强制选择"不使用"，但状态合法
}

// 3. 优化选择（最低优先级）
return Math.min(choice1, choice2);  // 在合法范围内选择最优方案
```

## 第六章：特殊约束问题的处理

### 6.1 等值约束 vs 不等值约束

动态规划问题中的约束条件有两种基本类型：

| 问题类型     | 约束条件      | 可能结果                  | 返回值处理   |
|----------|-----------|-----------------------|---------|
| **传统背包** | 容量 ≤ 限制值  | 总能找到解（最差的情况下唯一解就是最优解） | 直接返回最优值 |
| **零钱兑换** | 总金额 = 目标值 | 可能无解                  | 无解时返回-1 |

### 6.2 零钱兑换问题的特殊处理

**核心差异**：

- **传统背包**：即使无法完全填满背包，也能找到一个可行解（最坏情况：不选任何物品，价值为0）
- **零钱兑换**：必须精确凑出目标金额，否则就是无解

**代码实现的关键差异**：

#### 递归终止条件的处理

```java
// 传统背包：容量用完或物品用完都能返回有效值
if (capacity <= 0 || i == 0) {
    return 0; // 总能返回一个合法值
}

// 零钱兑换：必须区分"恰好凑出"和"无法凑出"
if (targetAmount == 0) {
    return 0; // 恰好凑出，需要0个硬币
}
if (i == 0) {
    return -1; // 无硬币但金额不为0，无解
}
```

#### 无解情况的传播处理

```java
// 零钱兑换需要特殊处理-1的传播
int choice1 = dfs(coins, i-1, amount);     // 不选当前硬币
int choice2 = dfs(coins, i, amount-coin);  // 选择当前硬币

// 关键：必须检查每个选择是否无解
if (choice2 == -1) {
    return choice1; // 选择2无解，只能用选择1
}
choice2 += 1; // 选择2有解，加上当前硬币

if (choice1 == -1) {
    return choice2; // 选择1无解，只能用选择2
}

return Math.min(choice1, choice2); // 两个都有解，选最优
```

**记忆要点**：

- 看到"恰好"、"等于"、"精确"等关键词 → 考虑无解情况
- 看到"不超过"、"至多"、"不大于" → 通常总有解

## 第七章：扫描顺序的内在规律

### 7.1 核心原理：依赖关系决定扫描顺序

在动态规划中，状态转移的依赖关系直接决定了我们应该采用什么样的扫描顺序。

### 7.2 i维度的扫描规律

**i的扫描顺序判断**：

- **正序（i++）**：当前行/层依赖上一行/层 → 从前往后计算
- **逆序（i--）**：当前行/层依赖下一行/层 → 从后往前计算（少见）

**典型场景**：

- 大多数DP问题：i正序扫描（如背包、LCS、最小路径和）
- 区间DP：i逆序扫描（先计算小区间，再计算大区间）

### 7.3 j维度的扫描规律

**j的扫描顺序判断**：

- **正序（j++）**：需要使用本行左边的**新值**（已更新值）
- **逆序（j--）**：需要使用本行左边的**旧值**（未更新值）

### 7.4 扫描顺序的核心原则 ⭐

**依赖关系决定扫描顺序**：

| 依赖模式                     | 扫描顺序     | 原因        | 典型问题  |
|--------------------------|----------|-----------|-------|
| **左上方依赖** `dp[i-1][j-k]` | **倒序扫描** | 需要旧值，必须保护 | 0-1背包 |
| **正左方依赖** `dp[i][j-k]`   | **正序扫描** | 需要新值，必须利用 | 完全背包  |
| **仅上方依赖** `dp[i-1][j]`   | **任意顺序** | 与当前行扫描无关  | 简单递推  |

### 7.5 实际应用示例

**0-1背包**：

```java
// 状态转移：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
//                                    ↑左上方依赖 → 倒序扫描
for (int i = 1; i <= n; i++) {
    for (int j = capacity; j >= w[i]; j--) { // 倒序保护旧值
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

**完全背包**：

```java
// 状态转移：dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])
//                                    ↑正左方依赖 → 正序扫描
for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= capacity; j++) { // 正序利用新值
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

**记忆口诀**：
> **"左上方要旧值，倒序来保护"**  
> **"正左方要新值，正序来更新"**

### 7.6 通用判断流程

**快速判断扫描顺序**：

```java
// 分析状态转移方程
dp[i][j] = f(dp[i-1][j], dp[i-1][j-k], dp[i][j-k], ...)
//           ↑正上方     ↑左上方      ↑正左方

// 判断依赖模式
if (有dp[i-1][j-k]项) {
    扫描顺序 = "倒序";  // 左上方依赖 → 需要旧值
} else if (有dp[i][j-k]项) {
    扫描顺序 = "正序";  // 正左方依赖 → 需要新值  
} else {
    扫描顺序 = "任意";  // 仅上方依赖 → 与当前行无关
}
```

**特殊情况处理**：

```java
// 对角线依赖：需要额外保存dp[i-1][j-1]
int prev = 0; 
for (int i = 1; i <= m; i++) {
    for (int j = 1; j <= n; j++) {
        int temp = dp[j];
        dp[j] = f(dp[j], dp[j-1], prev, ...);
        prev = temp;
    }
}
```

## 第八章：空间优化技巧

### 8.1 二维DP空间优化为一维的基本原理

**核心原理**：利用DP状态转移的局部性特征，用滚动更新替代全量存储。

### 8.2 优化可行性判断标准

#### 依赖关系分析

**可优化的典型模式**：

```java
// 模式1：只依赖上一行
dp[i][j] = f(dp[i-1][j], dp[i-1][j-k], dp[i-1][j+k], ...)

// 模式2：只依赖上一行和当前行的左边
dp[i][j] = f(dp[i-1][j], dp[i][j-k], ...)

// 模式3：只依赖当前行的左边（一维本质）
dp[i][j] = f(dp[i][j-k], ...)
```

**不可优化的模式**：

```java
// 依赖多行历史数据
dp[i][j] = f(dp[i-1][j], dp[i-2][j], dp[i-3][j], ...)

// 依赖当前行的右边（未计算的状态）
dp[i][j] = f(dp[i][j+k], ...)
```

#### 快速判断法则

> **"只看上一行 + 当前行左边 → 可优化"**
> **"需要多行历史 + 当前行右边 → 不可优化"**

### 8.3 空间优化的通用步骤

| 依赖模式            | 优化策略     | 空间复杂度   | 典型问题    |
|-----------------|----------|---------|---------|
| **只依赖上一行**      | 滚动数组（两行） | O(2×列数) | 最长公共子序列 |
| **依赖上一行+当前行左边** | 单行数组     | O(列数)   | 背包问题    |
| **只依赖当前行左边**    | 单行数组     | O(列数)   | 完全背包    |

### 8.4 经典问题的优化模式

#### 背包类问题

```java
// 原始二维DP
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);

// 一维优化（0-1背包）
for (int i = 1; i <= n; i++) {
    for (int j = capacity; j >= w[i]; j--) { // 逆序
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}

// 一维优化（完全背包）
for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= capacity; j++) { // 正序
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

#### 路径类问题

```java
// 原始二维DP
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);

// 一维优化
for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) { // 正序
        dp[j] = grid[i][j] + min(dp[j], dp[j-1]);
        //                        ↑上一行  ↑当前行左边
    }
}
```

### 8.5 优化效果评估

| 问题类型        | 原始空间复杂度       | 优化后空间复杂度    | 优化倍数      |
|-------------|---------------|-------------|-----------|
| **0-1背包**   | O(n×capacity) | O(capacity) | n倍        |
| **完全背包**    | O(n×capacity) | O(capacity) | n倍        |
| **最小路径和**   | O(m×n)        | O(min(m,n)) | max(m,n)倍 |
| **最长公共子序列** | O(m×n)        | O(min(m,n)) | max(m,n)倍 |

**记忆口诀**：
> **"上一行+左边 → 可优化"**  
> **"多行历史+右边 → 需谨慎"**

## 第九章：高级技巧与理论

### 9.1 状态扩展消除后效性

当遇到看似有后效性的问题时，不要放弃DP，而是考虑如何通过**状态扩展**来消除后效性。

#### 核心认知：重新定义"当前"

**状态扩展的本质**：将"非当前的过去状态"提升为"当前状态"的一部分。

**关键洞察**：

- **传统DP的"当前"**：只包含位置信息，如`dp[i] = 到达第i阶的方法数`
- **扩展后的"当前"**：包含位置信息+历史信息，如`dp[i][lastStep] = 到达第i阶且最后一步跳lastStep阶的方法数`

**信息完备性原理**：
> 扩展后的状态必须包含所有影响未来决策的历史信息

**记忆口诀**：
> **"过去变当前，历史成状态"**  
> **"扩展状态空间，消除后效性"**

#### 后效性识别标准

**有后效性的典型特征**：

- 当前决策会影响未来的选择空间
- 未来状态不仅依赖当前位置，还依赖"如何到达当前位置"
- 需要"历史信息"才能做出正确的未来决策

#### 状态扩展的一般方法论

**步骤1：识别影响因子**

- 找出影响未来决策的历史信息
- 确定这些信息的所有可能取值

**步骤2：扩展状态定义**

```java
// 原始状态：dp[i] = 到达位置i的最优解
// 扩展状态：dp[i][影响因子] = 到达位置i且影响因子为特定值的最优解
```

**步骤3：重新设计状态转移**

- 当前状态包含了影响未来的所有必要信息
- 状态转移时根据约束条件选择合法的前驱状态

#### 状态扩展的数学本质

**原始问题结构（有后效性）**：

```java
当前位置i的决策 = f(位置i, 如何到达位置i的历史路径)
//                ↑当前    ↑过去（影响未来）
```

**扩展后问题结构（无后效性）**：

```java
当前状态(i,history)的决策 = f(当前完整状态)
//                       ↑过去信息已成为当前状态的一部分
```

**核心公式**：
> **过去影响因子 + 当前位置信息 = 新的"当前完整状态"**

#### 经典问题的状态扩展模式

**约束选择类问题**：

```java
// 带约束爬楼梯：不能连续两次跳1阶
// 扩展状态：dp[i][j] = 到达第i阶且最后一步跳j阶的方法数
dp[i][1] = dp[i-1][2];           // 跳1阶，前一步必须是2阶
dp[i][2] = dp[i-2][1] + dp[i-2][2]; // 跳2阶，前一步可以是任意
```

**持有状态类问题**：

```java
// 股票买卖问题
// 扩展状态：dp[i][0/1] = 第i天不持股/持股的最大收益
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]); // 不持股
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]); // 持股
```

#### 实践中的"当前化"策略

**策略1：时间维度的当前化**

```java
// 将"过去的时间点状态"作为"当前时间点状态"的一个维度
dp[时间][过去状态] = 在特定时间点具有特定过去状态的最优解
```

**策略2：选择维度的当前化**

```java
// 将"过去的选择结果"作为"当前选择状态"的一个维度
dp[位置][过去选择] = 在特定位置具有特定过去选择的最优解
```

**策略3：约束维度的当前化**

```java
// 将"过去的约束消耗"作为"当前约束状态"的一个维度
dp[位置][剩余约束] = 在特定位置具有特定剩余约束的最优解
```

**操作步骤**：

1. **识别影响因子**：找出哪些"过去信息"会影响"未来决策"
2. **状态当前化**：将这些过去信息纳入当前状态定义
3. **验证完备性**：确保新状态包含了所有必要的决策信息
4. **重写转移方程**：基于完整的当前状态进行决策

**记忆口诀**：
> **"有后效性不可怕，状态扩展来解决"**  
> **"过去变当前，历史成状态"**

### 9.2 多维DP的等价性认知

对于任意维度的动态规划问题：

| 维度     | 状态空间形状 | 状态总数              | 时间复杂度    | 遍历方式 |
|--------|--------|-------------------|----------|------|
| **一维** | 线性数组   | n+1               | O(n)     | 单层循环 |
| **二维** | 矩形矩阵   | (n+1)×(m+1)       | O(n×m)   | 双重循环 |
| **三维** | 立方体    | (n+1)×(m+1)×(k+1) | O(n×m×k) | 三重循环 |

**核心洞察**：无论维度如何变化，动态规划的本质都是**"对状态空间的一次完整且无重复的遍历"**。

### 9.3 模板对比总结

| 特征        | 普通递归搜索 | 记忆化搜索         | 动态规划          |
|-----------|--------|---------------|---------------|
| **实现方式**  | 递归     | 递归+缓存         | 迭代循环          |
| **时间复杂度** | O(2^n) | O(n×capacity) | O(n×capacity) |
| **空间复杂度** | O(n)   | O(n×capacity) | O(n×capacity) |
| **缓存策略**  | 无      | 避开合法值(-1)     | 使用合法值(0)      |
| **计算顺序**  | 自顶向下   | 自顶向下          | 自底向上          |
| **适用场景**  | 理解问题结构 | 优化递归          | 生产环境          |

## 第十章：总结与实践指导

### 10.1 学习路径建议

1. **基础理论**：理解最优子结构和重叠子问题两大性质
2. **模板掌握**：熟练掌握三大实现模板
3. **状态设计**：学会正确定义状态和状态转移方程
4. **约束处理**：掌握约束处理的优先级原则
5. **扫描顺序**：理解依赖关系决定扫描顺序的规律
6. **空间优化**：掌握二维到一维的优化技巧
7. **高级技巧**：学会状态扩展等高级方法

### 10.2 常见问题类型

**背包类问题**：

- 0-1背包：每个物品只能选一次
- 完全背包：每个物品可以选多次
- 多重背包：每个物品有数量限制

**路径类问题**：

- 最小路径和：从起点到终点的最小代价
- 不同路径：从起点到终点的路径数量
- 带障碍物的路径：考虑障碍物的路径规划

**字符串类问题**：

- 最长公共子序列：两个字符串的最长公共部分
- 编辑距离：将一个字符串转换为另一个的最小操作数
- 回文子串：字符串中的回文结构

**序列类问题**：

- 最长递增子序列：序列中的递增部分
- 最大子数组和：连续子数组的最大和
- 买卖股票：股票交易的最大收益

### 10.3 实践建议

1. **从简单开始**：先掌握经典的背包问题和路径问题
2. **理解本质**：重点理解状态转移的逻辑，而不是死记模板
3. **多做练习**：通过大量练习加深对不同问题类型的理解
4. **总结规律**：及时总结不同问题的共同点和差异点
5. **优化意识**：在掌握基本解法后，考虑空间和时间优化

**记忆口诀**：
> **"状态定义要清晰，转移方程是核心"**
> **"边界处理要仔细，扫描顺序有规律"**
> **"空间优化看依赖，高级技巧解难题"**

## 动态规划两大核心性质的代码体现

### 1. 最优子结构性质

**定义**：一个问题的最优解包含其子问题的最优解。

**在背包问题中的具体体现**：

**0-1背包状态转移方程**：

```java
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
```

**最优子结构体现在**：

- **第一项 `dp[i-1][j]`**：表示"不选第i个物品"时的最优解，这个解就是**前i-1个物品在容量j下的最优解**
- **第二项 `dp[i-1][j-w[i]] + v[i]`**：表示"选第i个物品"时的最优解，这个解等于**前i-1个物品在剩余容量j-w[i]下的最优解**
  加上当前物品价值

**完全背包状态转移方程**：

```java
dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])
```

**关键认知**：整个问题的最优解（dp[i][j]）完全由两个子问题的最优解组合而成，没有任何额外信息。

### 2. 重叠子问题性质

**定义**：在递归求解过程中，许多子问题会被重复计算。

**在代码中的具体体现**：

**从DFS递归结构看**：

```java
// knapsacksDfs方法中的递归调用
int no = knapsacksDfs(weights, values, item - 1, capacity);
int yes = knapsacksDfs(weights, values, item - 1, capacity - weights[item - 1]) + values[item - 1];
```

**重叠子问题的证据**：

- **同一个子问题被多次调用**：例如计算`f(5,10)`时，`f(3,7)`这个子问题可能在不同路径下被多次计算
- **状态空间远小于搜索空间**：虽然有2^n种选择组合，但只有`(n+1) × (capacity+1)`个**不同的子问题状态**

**从记忆化优化看**：

```java
// knapsacksMemoization方法中的缓存检查
if (memo[item][capacity] != -1) {
    return memo[item][capacity];
}
```

**这直接证明了重叠子问题的存在**：

- 如果没有重叠子问题，记忆化就没有意义
- 正是因为`f(i,j)`这个子问题会被多次访问，缓存才有价值

### 3. 具体示例验证

以物品`[2,3,4]`，价值`[4,5,6]`，容量`8`为例：

```
计算f(3,8)时：
├── 需要f(2,8)  ← 重叠子问题
│   ├── 需要f(1,8)  ← 重叠子问题
│   └── 需要f(1,5)  ← 重叠子问题
└── 需要f(2,4)  ← 重叠子问题
    ├── 需要f(1,4)  ← 重叠子问题（已计算过）
    └── 需要f(1,1)  ← 重叠子问题
```

可以看到`f(1,8)`、`f(1,5)`、`f(1,4)`等子问题被**多次重复计算**，这正是重叠子问题的典型特征。

### 4. 两大性质的统一认知框架

| 性质        | 在公式中的体现       | 在代码中的体现           | 优化意义        |
|-----------|---------------|-------------------|-------------|
| **最优子结构** | 当前状态由子状态最优解组合 | `max(子问题1, 子问题2)` | 保证局部最优→全局最优 |
| **重叠子问题** | 相同子状态被多次引用    | 记忆化缓存的必要性         | 指数级→多项式级优化  |

**核心洞察**：这两个性质共同构成了DP高效性的基础：

- **最优子结构**保证了我们可以用子问题的最优解构建原问题的最优解
- **重叠子问题**使得记忆化/动态规划成为可能，将时间复杂度从指数级降为多项式级

### 5. 从理论到实践的映射

**在记忆化搜索中**：

- **最优子结构**：体现在状态转移方程的构建上
- **重叠子问题**：体现在缓存机制的设计上

**在动态规划中**：

- **最优子结构**：体现在状态转移方程的正确性上
- **重叠子问题**：体现在迭代计算的顺序安排上

**关键认知**：理解这两个性质不仅有助于正确实现算法，更重要的是能够：

1. **验证算法的正确性**：确保状态转移方程确实体现了最优子结构
2. **优化算法效率**：通过识别重叠子问题来设计合适的缓存策略
3. **扩展到新问题**：判断一个新问题是否适合用DP解决

## 状态扩展消除后效性的一般原则 ⭐

### 核心认知：后效性问题的DP解决方案

当遇到看似有后效性的问题时，不要放弃DP，而是考虑如何通过**状态扩展**来消除后效性。

### 1. 后效性识别标准

**有后效性的典型特征**：

- 当前决策会影响未来的选择空间
- 未来状态不仅依赖当前位置，还依赖"如何到达当前位置"
- 需要"历史信息"才能做出正确的未来决策

**经典例子**：

```java
// 带约束爬楼梯：不能连续两次跳1阶
// 当前决策（跳1阶还是2阶）会影响下一步的选择空间
// 如果这一步跳1阶，下一步就不能跳1阶
```

### 2. 状态扩展的一般方法论

#### 2.1 识别影响因子

**步骤1：找出影响未来决策的历史信息**

- 分析什么样的"过去信息"会限制"未来选择"
- 确定这些信息的所有可能取值

**示例分析**：

```java
// 爬楼梯约束问题
// 影响因子：上一步跳了几阶（1阶或2阶）
// 可能取值：{1, 2}

// 股票买卖问题  
// 影响因子：当前是否持有股票
// 可能取值：{持有, 不持有}

// 打家劫舍问题
// 影响因子：上一家是否被偷
// 可能取值：{偷了, 没偷}
```

#### 2.2 扩展状态定义

**原始状态**：`dp[i]` = 到达位置i的最优解
**扩展状态**：`dp[i][影响因子]` = 到达位置i且影响因子为特定值的最优解

**状态扩展模式**：

```java
// 一般形式
dp[当前位置][影响未来的历史信息] = 最优解

// 具体示例
dp[i][lastStep] = 到达第i阶且最后一步跳lastStep阶的方法数
dp[i][hasStock] = 第i天结束时持股状态为hasStock的最大收益
dp[i][robbed] = 考虑前i家且第i家偷窃状态为robbed的最大收益
```

#### 2.3 重新设计状态转移

**扩展后的状态转移特点**：

- 当前状态包含了影响未来的所有必要信息
- 状态转移时根据约束条件选择合法的前驱状态
- 重新满足无后效性：未来只依赖当前扩展状态，不需要更多历史

### 3. 经典问题的状态扩展模式

#### 3.1 约束选择类问题

```java
// 带约束爬楼梯
// 原状态：dp[i] = 到达第i阶的方法数（有后效性）
// 扩展状态：dp[i][j] = 到达第i阶且最后一步跳j阶的方法数（无后效性）

dp[i][1] = dp[i-1][2];           // 跳1阶，前一步必须是2阶
dp[i][2] = dp[i-2][1] + dp[i-2][2]; // 跳2阶，前一步可以是任意
```

#### 3.2 持有状态类问题

```java
// 股票买卖问题
// 原状态：dp[i] = 第i天的最大收益（有后效性，不知道是否持股）
// 扩展状态：dp[i][0/1] = 第i天不持股/持股的最大收益（无后效性）

dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]); // 不持股
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]); // 持股
```

#### 3.3 操作次数类问题

```java
// 限制交易次数的股票问题
// 扩展状态：dp[i][k][0/1] = 第i天最多k次交易且持股状态的最大收益

dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
```

### 4. 状态扩展的设计原则

#### 4.1 最小充分原则

**只包含必要的历史信息**：

- ✅ 包含所有影响未来决策的信息
- ❌ 不包含冗余或无关的历史信息
- 目标：状态空间尽可能小，但足以消除后效性

#### 4.2 完备性原则

**覆盖所有可能的历史状态**：

- 确保扩展后的状态能够表示原问题的所有可能情况
- 不能遗漏任何可能的历史信息组合

#### 4.3 转移合法性原则

**状态转移必须符合问题约束**：

- 从一个扩展状态只能转移到约束允许的其他扩展状态
- 非法转移应该被明确排除或标记为不可达

### 5. 实践指导流程

```java
// 步骤1：识别后效性
if (当前决策影响未来选择空间) {
    // 步骤2：分析影响因子
    List<String> 影响因子 = 找出影响未来的历史信息();
    
    // 步骤3：设计扩展状态
    // dp[位置][影响因子1][影响因子2]...
    
    // 步骤4：重写状态转移方程
    // 根据约束条件，从合法的前驱状态转移
    
    // 步骤5：验证无后效性
    // 确保扩展状态包含了所有必要信息
}
```

### 6. 核心洞察总结

**状态扩展的本质**：
> 将"影响未来的历史信息"编码到状态中，使得当前状态成为未来决策的充分条件

**记忆口诀**：
> **"有后效性不可怕，状态扩展来解决"**
> - 识别影响因子 → 扩展状态空间 → 重新设计转移 → 恢复无后效性

**适用范围**：

- 约束选择问题（如带限制的路径、背包问题）
- 状态持有问题（如股票买卖、游戏状态）
- 操作次数限制问题（如有限次数的操作优化）
- 序列依赖问题（如马尔可夫决策过程）

这个原则是动态规划中的高级技巧，掌握它可以解决很多看似复杂的"有后效性"问题。

## 二维DP空间优化为一维的一般方法论 ⭐

### 核心原理：状态依赖关系分析

二维DP能否优化为一维，关键在于分析**状态转移的依赖关系**。

### 1. 优化可行性判断标准

#### 1.1 依赖关系分析

**可优化的典型模式**：

```java
// 模式1：只依赖上一行
dp[i][j] = f(dp[i-1][j], dp[i-1][j-k], dp[i-1][j+k], ...)

// 模式2：只依赖上一行和当前行的左边
dp[i][j] = f(dp[i-1][j], dp[i][j-k], ...)

// 模式3：只依赖当前行的左边（一维本质）
dp[i][j] = f(dp[i][j-k], ...)
```

**不可优化的模式**：

```java
// 依赖多行历史数据
dp[i][j] = f(dp[i-1][j], dp[i-2][j], dp[i-3][j], ...)

// 依赖当前行的右边（未计算的状态）
dp[i][j] = f(dp[i][j+k], ...)

// 复杂的跨行依赖
dp[i][j] = f(dp[i-2][j-1], dp[i-1][j+1], ...)
```

#### 1.2 快速判断法则

> **"只看上一行 + 当前行左边 → 可优化"**
> **"需要多行历史 + 当前行右边 → 不可优化"**

### 2. 空间优化的通用步骤

#### 2.1 步骤1：确认依赖模式

```java
// 分析原始状态转移方程
dp[i][j] = f(dp[i-1][...], dp[i][j-...], ...)
//           ↑上一行      ↑当前行左边
```

#### 2.2 步骤2：选择优化策略

| 依赖模式            | 优化策略     | 空间复杂度   | 典型问题    |
|-----------------|----------|---------|---------|
| **只依赖上一行**      | 滚动数组（两行） | O(2×列数) | 最长公共子序列 |
| **依赖上一行+当前行左边** | 单行数组     | O(列数)   | 背包问题    |
| **只依赖当前行左边**    | 单行数组     | O(列数)   | 完全背包    |

#### 2.3 步骤3：确定扫描顺序

```java
// 关键决策：j的扫描方向
if (需要当前行左边的旧值) {
    // j逆序扫描（如0-1背包）
    for (int j = capacity; j >= weight[i]; j--) {
        dp[j] = f(dp[j], dp[j-weight[i]], ...);
    }
} else if (需要当前行左边的新值) {
    // j正序扫描（如完全背包）
    for (int j = weight[i]; j <= capacity; j++) {
        dp[j] = f(dp[j], dp[j-weight[i]], ...);
    }
}
```

### 3. 经典问题的优化模式

#### 3.1 背包类问题

```java
// 原始二维DP
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);

// 一维优化（0-1背包）
for (int i = 1; i <= n; i++) {
    for (int j = capacity; j >= w[i]; j--) { // 逆序
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}

// 一维优化（完全背包）
for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= capacity; j++) { // 正序
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

#### 3.2 路径类问题

```java
// 原始二维DP
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);

// 一维优化
for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) { // 正序
        dp[j] = grid[i][j] + min(dp[j], dp[j-1]);
        //                        ↑上一行  ↑当前行左边
    }
}
```

#### 3.3 字符串匹配类问题

```java
// 原始二维DP（最长公共子序列）
if (s1[i-1] == s2[j-1]) {
    dp[i][j] = dp[i-1][j-1] + 1;
} else {
    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
}

// 滚动数组优化（需要保存dp[i-1][j-1]）
int prev = 0; // 保存dp[i-1][j-1]
for (int i = 1; i <= m; i++) {
    for (int j = 1; j <= n; j++) {
        int temp = dp[j]; // 保存当前dp[j]作为下次的prev
        if (s1[i-1] == s2[j-1]) {
            dp[j] = prev + 1;
        } else {
            dp[j] = max(dp[j], dp[j-1]);
        }
        prev = temp;
    }
}
```

### 4. 优化过程中的常见陷阱

#### 4.1 扫描顺序错误

```java
// 错误示例：0-1背包使用正序扫描
for (int j = w[i]; j <= capacity; j++) { // 错误！
    dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    // dp[j-w[i]]已被更新，导致重复选择
}
```

#### 4.2 边界条件处理

```java
// 正确处理：确保j-w[i] >= 0
for (int j = capacity; j >= w[i]; j--) { // 正确
    dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
}
```

#### 4.3 状态保存遗漏

```java
// LCS优化时需要额外保存dp[i-1][j-1]
int prev = dp[0]; // 保存dp[i-1][j-1]
for (int j = 1; j <= n; j++) {
    int temp = dp[j];
    // ... 状态转移 ...
    prev = temp; // 更新prev为下一轮的dp[i-1][j-1]
}
```

### 5. 优化效果评估

| 问题类型        | 原始空间复杂度       | 优化后空间复杂度    | 优化倍数      |
|-------------|---------------|-------------|-----------|
| **0-1背包**   | O(n×capacity) | O(capacity) | n倍        |
| **完全背包**    | O(n×capacity) | O(capacity) | n倍        |
| **最小路径和**   | O(m×n)        | O(min(m,n)) | max(m,n)倍 |
| **最长公共子序列** | O(m×n)        | O(min(m,n)) | max(m,n)倍 |
| **编辑距离**    | O(m×n)        | O(min(m,n)) | max(m,n)倍 |

### 6. 实践指导原则

#### 6.1 何时进行空间优化

- ✅ **内存受限环境**：嵌入式系统、移动设备
- ✅ **大规模数据**：当m×n很大时，优化效果显著
- ✅ **生产环境**：提高系统整体性能
- ❌ **调试阶段**：二维数组更便于理解和调试

#### 6.2 优化决策流程

```java
// 决策流程
if (内存充足 && 处于开发调试阶段) {
    使用二维DP; // 便于理解和调试
} else if (状态转移只依赖上一行和当前行左边) {
    进行空间优化; // 显著减少内存使用
} else {
    保持二维DP; // 复杂依赖关系不适合优化
}
```

### 7. 核心洞察总结

**空间优化的本质**：
> 利用DP状态转移的**局部性特征**，用**滚动更新**替代**全量存储**

**记忆口诀**：
> **"上一行+左边 → 可优化"**  
> **"多行历史+右边 → 需谨慎"**

**通用模板**：

```java
// 二维DP空间优化通用模板
// 1. 分析依赖：确定需要上一行的哪些位置
// 2. 选择策略：单行数组 vs 滚动数组
// 3. 确定顺序：正序 vs 逆序扫描
// 4. 处理边界：确保索引不越界
// 5. 保存必要状态：如dp[i-1][j-1]

for (int i = 1; i <= n; i++) {
    // 可能需要保存一些状态
    for (int j = 扫描起点; 扫描条件; 扫描方向) {
        // 状态转移
        dp[j] = f(dp[j], dp[j±k], saved_states, ...);
    }
}
```

这个方法论适用于绝大多数二维DP问题的空间优化，是提高算法实用性的重要技巧。