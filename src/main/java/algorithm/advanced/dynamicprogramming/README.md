# 背包问题算法认知总结

## 动态规划约束处理优先级原则 ⭐

在动态规划问题中，约束条件的处理遵循严格的优先级顺序：

### 1. 资源约束优先原则（最高优先级）
- **定义**：当资源出现极值时，选择空间受限但DP状态仍然合法
- **特征**：资源不足以支持某种选择（如硬币面额 > 目标金额）
- **处理方式**：强制选择特定路径，DP值继承合法状态
- **关键洞察**：**资源极值时，状态极值的DP是合法的**

### 2. 状态边界检查原则（次优先级）
- **定义**：当状态出现极值时，可能违反问题的基本约束
- **特征**：状态参数达到边界值（如没有物品可选、字符串为空等）
- **处理方式**：返回非法标记或边界值
- **关键洞察**：**状态极值时，DP可能非法**

### 3. 优化选择原则（最低优先级）
- **定义**：在合法范围内选择最优方案
- **特征**：比较多个可行方案的优劣
- **处理方式**：使用min/max函数选择最优解

### 优先级关系
```
资源约束优先原则 > 状态边界检查原则 > 优化选择原则
```

这个原则适用于所有动态规划问题：
- **零钱兑换**：硬币面额约束 > 硬币数量边界 > 最少硬币数优化
- **01背包**：重量约束 > 物品边界 > 价值优化  
- **最长公共子序列**：字符匹配约束 > 字符串边界 > 长度优化
- **路径问题**：障碍约束 > 边界检查 > 路径优化

### 代码实现体现

**在零钱兑换问题中的应用**：
```java
// 1. 状态边界检查（次优先级）
if (i == 0) {
    return -1;  // 无硬币无法凑出正金额，非法状态
}

// 2. 资源约束检查（最高优先级）
if (coins[i-1] > targetAmount) {
    return subProblemChoice;  // 硬币太大，强制选择"不使用"，但状态合法
}

// 3. 优化选择（最低优先级）
return Math.min(choice1, choice2);  // 在合法范围内选择最优方案
```

**理论价值**：
1. **调试指导**：当DP出现异常时，按优先级顺序检查约束
2. **代码结构**：按优先级顺序组织if-else判断逻辑  
3. **算法设计**：设计新DP问题时的约束处理思路

## 状态转移方程的深度认知 ⭐

### 核心问题：为什么选择后的子问题是 `dp[i][j-cost]`？

在资源约束类DP问题中，我们经常看到这样的模式：
```java
// 无限制重复选择问题（完全背包、硬币兑换）
dp[i][j] = f(dp[i-1][j], dp[i][j-cost] + benefit)

// 一次性选择问题（01背包）  
dp[i][j] = f(dp[i-1][j], dp[i-1][j-cost] + benefit)
```

### 问题分解的本质

**数学递推的逻辑**：
- **原问题**：用前i种资源，在约束j下的最优解
- **选择第i种资源后的新问题**：用前i种资源，在约束(j-cost)下的最优解
- 这个新问题的解，加上当前选择的收益，就是选择当前资源的总收益

**关键洞察**：
当我们做出选择时，问题规模确实缩小了（从"约束j"变成"约束j-cost"），
这个缩小后的问题的最优解，就是我们要利用的子问题解。

### 核心区别：dp[i] vs dp[i-1]

**为什么有时是dp[i]，有时是dp[i-1]？**

| 问题类型 | 状态转移 | 含义 | 典型问题 |
|---------|---------|------|---------|
| **无限制重复** | `dp[i][j-cost]` | 选择后仍可继续使用该资源 | 完全背包、硬币兑换、爬楼梯 |
| **一次性选择** | `dp[i-1][j-cost]` | 选择后不能再使用该资源 | 01背包、任务调度 |

**子问题的含义对比**：
- **dp[i][j-cost]**：在已经选择了一个资源i的前提下，用前i种资源（包括可以继续选择资源i）在剩余约束下的最优解
- **dp[i-1][j-cost]**：在已经"消耗"了资源i的前提下，用前i-1种资源在剩余约束下的最优解

### 具体示例对比

**硬币兑换问题（无限制重复）**：
```java
// 原问题：用前i种硬币凑出金额j
// 选择第i种硬币后：用前i种硬币凑出金额(j-coins[i-1])
dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
//         ↑不选择      ↑选择后仍可继续使用该硬币
```

**01背包问题（一次性选择）**：
```java
// 原问题：用前i种物品，在容量j下获得最大价值
// 选择第i种物品后：用前i-1种物品，在容量(j-weight[i-1])下获得最大价值
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i-1]] + value[i-1])
//             ↑不选择      ↑选择后不能再使用该物品
```

### 适用范围总结

**dp[i][j-cost] 模式适用于**：
- ✅ 完全背包问题（物品可重复选择）
- ✅ 硬币兑换问题（硬币可重复使用）
- ✅ 爬楼梯问题（每种步长可重复使用）
- ✅ 数字组合问题（数字可重复使用）

**dp[i-1][j-cost] 模式适用于**：
- ✅ 01背包问题（每个物品只能选一次）
- ✅ 任务调度问题（每个任务只能执行一次）
- ✅ 股票买卖问题（有冷却期限制）

### 记忆口诀

> **"能重复用i，不能重复用i-1"**
> - 资源可以重复使用 → 子问题仍在第i层 → dp[i][j-cost]
> - 资源只能使用一次 → 子问题降到第i-1层 → dp[i-1][j-cost]

## 三大算法模板

### 1. 普通递归搜索模板
```
1. 定义递归函数和参数（状态表示）
2. 处理单一维度边界条件（递归终止条件）
3. 处理维度相互干涉约束条件（资源不足时的处理）
4. 枚举所有可能的决策选择
5. 递归求解子问题
6. 合并子问题结果，返回最优解
```

**适用范围**：
- 背包问题：95%适用
- 所有DP问题：85%适用
- 其他递归问题：70%适用

### 2. 记忆化搜索模板
```
1. 基于普通递归搜索
2. 初始化备忘录（关键：避开合法返回值，如用-1避开0）
3. 处理单一维度边界条件（递归终止）
4. 检查缓存：如果本层已计算，直接返回（前提：初始化时避开了所有合法返回值）
   【关键认知】：每一层只处理本层的缓存，不处理子问题的缓存
5. 专门处理维度相互干涉约束条件（如容量不足）
6. 枚举决策，递归求解子问题
7. 合并子问题结果
8. 缓存本层结果并返回
```

**关键认知**：
- **"避开合法值"**：用-1避开0这个合法返回值
- **"每层只处理本层缓存"**：不要替子问题做决定
- **"专门处理资源约束"**：约束不满足时的处理逻辑往往不同

### 3. 动态规划模板
```
1. 定义状态：dp[i][j]的含义
2. 处理单一维度边界条件和维度相互干涉特殊情况
3. 初始化DP表（关键：使用合法值初始化，如边界状态设为0）
4. 【重要】：不使用递归，采用迭代方式（嵌套循环）
5. 确定状态转移顺序（通常是嵌套循环）
6. 在循环中：
   - 专门处理资源约束条件（如容量不足）
   - 枚举决策选择
   - 应用状态转移方程
   - 更新DP表
7. 返回目标状态的值
```

**关键认知**：
- **"使用合法值初始化"**：直接用0初始化边界状态（因为0就是正确答案）
- **"DP不做递归"**：用循环替代递归，避免栈溢出
- **"专门处理资源约束"**：这是背包类问题的核心

## 核心洞察：从"有重复组合"到"无重复组合"的优化

### 1. 暴力搜索（DFS）的认知
暴力搜索构建了一个**高度为n的决策树**：
- **树的高度**：n层（对应n个物品）
- **每层分叉**：2个选择（选或不选当前物品）
- **总节点数**：2^n个（指数级增长）
- **重复计算**：同一个子问题在不同路径下被多次访问

**决策树可视化**：
```
                   f(n, capacity)
                  /              \
        f(n-1, capacity)    f(n-1, capacity-w[n-1])
           /        \              /        \
  f(n-2,...)  f(n-2,...)  f(n-2,...)  f(n-2,...)
```

**复杂度分析**：
- 时间复杂度：O(2^n) - 对应树的节点总数
- 空间复杂度：O(n) - 递归调用栈的深度（树的高度）

### 2. 记忆化搜索的优化原理
记忆化搜索实现了从**"有重复组合"到"无重复组合"**的关键优化：

**优化前（DFS）**：
- 同一个子问题被重复计算多次
- 形成"有重复组合"的搜索过程
- 时间复杂度：指数级 O(2^n)

**优化后（记忆化搜索）**：
- 每个子问题只计算一次
- 形成"无重复组合"的搜索过程
- 时间复杂度：多项式级 O(n × capacity)

### 3. 等价性认知
记忆化搜索的复杂度分析：
- **状态总数**：(n+1) × (capacity+1) 个不同的子问题
- **每个状态计算时间**：O(1) - 只需常数时间的比较和加法
- **总时间复杂度**：状态数 × 每个状态的计算时间 = O(n × capacity)

**关键认知**：这确实等价于一次"没有重复的遍历搜索"：
- 相当于遍历了一个 (n+1) × (capacity+1) 的二维表格
- 每个格子只计算一次，没有重复计算
- 与嵌套循环 `for(i=0..n) for(j=0..capacity)` 的遍历次数完全相同

### 4. 一般性结论
对于动态规划问题：
- **暴力搜索**：通常对应一个高度为n的决策树，每层分叉数由选择数决定
- **记忆化优化**：将指数级复杂度降为多项式级复杂度
- **双层for循环**：本质上都是"无重复选择"的遍历过程

这个认知适用于所有能用动态规划解决的问题，是理解算法优化的核心钥匙。

## 零钱兑换问题：等值约束的特殊处理

### 问题特点
零钱兑换问题是完全背包问题的一个重要变种，其核心区别在于约束条件的性质：

| 问题类型 | 约束条件 | 可能结果 | 返回值处理 |
|---------|----------|----------|------------|
| **传统背包** | 容量 ≤ 限制值 | 总能找到解 | 直接返回最优值 |
| **零钱兑换** | 总金额 = 目标值 | 可能无解 | 无解时返回-1 |

### 核心认知：等值约束 vs 不等值约束

**传统背包问题（不等值约束）**：
- 约束：`weight ≤ capacity`
- 特点：即使无法完全填满背包，也能找到一个可行解
- 最坏情况：不选任何物品，价值为0（仍是合法解）

**零钱兑换问题（等值约束）**：
- 约束：`amount = targetAmount`
- 特点：必须精确凑出目标金额，否则就是无解
- 无解情况：无法用给定硬币组合出目标金额

### 代码实现的关键差异

#### 1. 递归终止条件的处理
```java
// 传统背包：容量用完或物品用完都能返回有效值
if (capacity <= 0 || i == 0) {
    return 0; // 总能返回一个合法值
}

// 零钱兑换：必须区分"恰好凑出"和"无法凑出"
if (targetAmount == 0) {
    return 0; // 恰好凑出，需要0个硬币
}
if (i == 0) {
    return -1; // 无硬币但金额不为0，无解
}
```

#### 2. 无解情况的传播处理
```java
// 零钱兑换需要特殊处理-1的传播
int choice1 = dfs(coins, i-1, amount);     // 不选当前硬币
int choice2 = dfs(coins, i, amount-coin);  // 选择当前硬币

// 关键：必须检查每个选择是否无解
if (choice2 == -1) {
    return choice1; // 选择2无解，只能用选择1
}
choice2 += 1; // 选择2有解，加上当前硬币

if (choice1 == -1) {
    return choice2; // 选择1无解，只能用选择2
}

return Math.min(choice1, choice2); // 两个都有解，选最优
```

#### 3. 状态转移方程的差异
```java
// 传统背包：直接比较，不用担心无解
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);

// 零钱兑换：需要处理-1的特殊情况
if (dp[i][j-coins[i-1]] != -1) {
    dp[i][j] = min(dp[i-1][j], dp[i][j-coins[i-1]] + 1);
} else {
    dp[i][j] = dp[i-1][j]; // 当前选择无解，只能不选
}
```

### 实际应用场景

**零钱兑换类问题**：
- 硬币找零问题
- 数字组合问题（组合和等于目标值）
- 完全平方数问题
- 单词拆分问题

**传统背包类问题**：
- 资源分配问题
- 投资组合问题
- 任务调度问题

### 关键洞察

**为什么零钱兑换需要特殊处理？**

1. **约束的严格性**：等值约束比不等值约束更严格，容错性更低
2. **解的存在性**：不是所有目标金额都能被给定硬币组合凑出
3. **错误传播**：一个无解的子问题会影响整个问题的求解策略

**记忆要点**：
- 看到"恰好"、"等于"、"精确"等关键词 → 考虑无解情况
- 看到"不超过"、"至多"、"不大于" → 通常总有解
- 等值约束问题需要额外的无解检查和错误处理逻辑

## 模板对比总结

| 特征 | 普通递归搜索 | 记忆化搜索 | 动态规划 |
|------|-------------|------------|----------|
| **实现方式** | 递归 | 递归+缓存 | 迭代循环 |
| **时间复杂度** | O(2^n) | O(n×capacity) | O(n×capacity) |
| **空间复杂度** | O(n) | O(n×capacity) | O(n×capacity) |
| **缓存策略** | 无 | 避开合法值(-1) | 使用合法值(0) |
| **计算顺序** | 自顶向下 | 自顶向下 | 自底向上 |
| **资源约束处理** | 专门处理 | 专门处理 | 专门处理 |
| **适用场景** | 理解问题结构 | 优化递归 | 生产环境 |

## 多维DP的等价性认知

### 1. 一维DP的等价性认知
**状态空间**：线性的一维表格
- **状态总数**：n+1 个不同的子问题（对应dp[0..n]）
- **每个状态计算时间**：O(1) - 常数时间的比较和加法
- **总时间复杂度**：状态数 × 每个状态的计算时间 = **O(n)**

**关键认知**：这等价于一次"没有重复的线性遍历"：
- 相当于从左到右遍历了一个长度为 n+1 的一维数组
- 每个位置只计算一次，没有重复计算
- 与单层循环 `for(i=0..n)` 的遍历次数完全相同

**典型应用**：斐波那契数列、最长递增子序列、一维背包

### 2. 二维DP的等价性认知
**状态空间**：矩形的二维表格
- **状态总数**：(n+1) × (m+1) 个不同的子问题（对应dp[0..n][0..m]）
- **每个状态计算时间**：O(1) - 常数时间的比较和加法
- **总时间复杂度**：状态数 × 每个状态的计算时间 = **O(n × m)**

**关键认知**：这等价于一次"没有重复的矩阵遍历"：
- 相当于逐行逐列遍历了一个 (n+1) × (m+1) 的二维矩阵
- 每个格子只计算一次，没有重复计算
- 与嵌套循环 `for(i=0..n) for(j=0..m)` 的遍历次数完全相同

**典型应用**：最长公共子序列、编辑距离、二维背包、区间DP

### 3. 三维DP的等价性认知
**状态空间**：立方体的三维空间
- **状态总数**：(n+1) × (m+1) × (k+1) 个不同的子问题（对应dp[0..n][0..m][0..k]）
- **每个状态计算时间**：O(1) - 常数时间的比较和加法
- **总时间复杂度**：状态数 × 每个状态的计算时间 = **O(n × m × k)**

**关键认知**：这等价于一次"没有重复的三维空间遍历"：
- 相当于逐层逐行逐列遍历了一个 (n+1) × (m+1) × (k+1) 的三维立方体
- 每个空间点只计算一次，没有重复计算
- 与三重嵌套循环 `for(i=0..n) for(j=0..m) for(k=0..k)` 的遍历次数完全相同

**典型应用**：三维背包、多字符串比较、复杂状态转移问题

### 4. 统一认知框架
对于任意维度的动态规划问题：

| 维度 | 状态空间形状 | 状态总数 | 时间复杂度 | 遍历方式 |
|------|-------------|----------|------------|----------|
| **一维** | 线性数组 | n+1 | O(n) | 单层循环 |
| **二维** | 矩形矩阵 | (n+1)×(m+1) | O(n×m) | 双重循环 |
| **三维** | 立方体 | (n+1)×(m+1)×(k+1) | O(n×m×k) | 三重循环 |
| **d维** | d维超立方体 | ∏(xi+1) | O(∏xi) | d重循环 |

**核心洞察**：无论维度如何变化，动态规划的本质都是**"对状态空间的一次完整且无重复的遍历"**。维度的增加只是将遍历空间从一维直线扩展到二维平面、三维空间，乃至更高维的超空间，但优化原理和复杂度分析的方法论完全一致。

## DP扫描模式的内在规律

### 核心原理：依赖关系决定扫描顺序

在动态规划中，状态转移的依赖关系直接决定了我们应该采用什么样的扫描顺序。这个规律适用于所有维度的DP问题。

### 1. i维度的扫描规律

**i的扫描顺序判断**：
- **正序（i++）**：当前行/层依赖上一行/层 → 从前往后计算
- **逆序（i--）**：当前行/层依赖下一行/层 → 从后往前计算（少见）

**典型场景**：
- 大多数DP问题：i正序扫描（如背包、LCS、最小路径和）
- 区间DP：i逆序扫描（先计算小区间，再计算大区间）

### 2. j维度的扫描规律

**j的扫描顺序判断**：
- **正序（j++）**：需要使用本行左边的**新值**（已更新值）
- **逆序（j--）**：需要使用本行左边的**旧值**（未更新值）

### 3. 典型问题的扫描模式

| 问题类型 | i扫描 | j扫描 | 状态转移特点 | 原因分析 |
|---------|------|------|-------------|----------|
| **0-1背包** | 正序 | 逆序 | `dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])` | 避免重复选择同一物品 |
| **完全背包** | 正序 | 正序 | `dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])` | 允许重复选择同一物品 |
| **最小路径和** | 正序 | 正序 | `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])` | 路径连续性要求 |
| **最长公共子序列** | 正序 | 正序 | `dp[i][j] = dp[i-1][j-1] + 1` 或 `max(...)` | 字符匹配的顺序性 |
| **区间DP** | 逆序 | 正序 | `dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost)` | 先计算小区间再计算大区间 |

### 4. 背包问题扫描顺序深度解析

#### 4.1 完全背包 vs 0-1背包的核心差异

**根本原因：依赖关系的不同**

1. **0-1背包的状态转移**：
   ```
   dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
   ```
   - 选择物品i时，依赖的是`dp[i-1][j-w[i]]`（上一行的值）
   - 每个物品最多只能选择一次

2. **完全背包的状态转移**：
   ```
   dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])
   ```
   - 选择物品i时，依赖的是`dp[i][j-w[i]]`（当前行的值）
   - 物品可以重复选择多次

#### 4.2 空间优化后的影响

**0-1背包（需要逆序）**：
```java
// 状态转移：dp[j] = max(dp[j], dp[j-w[i]] + v[i])
// 需要的dp[j-w[i]]应该是"上一轮的旧值"（相当于dp[i-1][j-w[i]]）
for (int i = 1; i <= n; i++) {
    for (int j = capacity; j >= w[i]; j--) { // 逆序扫描
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```
- 如果正序扫描，`dp[j-w[i]]`会被提前更新，变成"当前轮的新值"
- 这会导致同一物品被重复选择，违反0-1背包约束
- 因此必须逆序扫描，保证使用的是未被更新的旧值

**完全背包（可以正序）**：
```java
// 状态转移：dp[j] = max(dp[j], dp[j-w[i]] + v[i])
// 需要的dp[j-w[i]]就是"当前轮的新值"（相当于dp[i][j-w[i]]）
for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= capacity; j++) { // 正序扫描
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```
- 正序扫描时，`dp[j-w[i]]`已被更新，这正是我们需要的
- 这样可以实现物品的重复选择，符合完全背包的要求

#### 4.3 具体示例对比

假设物品1：重量2，价值3，容量为6

**0-1背包（逆序j=6,5,4,3,2,1）**：
```
j=6: dp[6] = max(dp[6], dp[4] + 3) = max(0, 0+3) = 3
j=4: dp[4] = max(dp[4], dp[2] + 3) = max(0, 0+3) = 3  
j=2: dp[2] = max(dp[2], dp[0] + 3) = max(0, 0+3) = 3
```
结果：物品1最多选择1次，dp[6]=3

**完全背包（正序j=1,2,3,4,5,6）**：
```
j=2: dp[2] = max(dp[2], dp[0] + 3) = max(0, 0+3) = 3
j=4: dp[4] = max(dp[4], dp[2] + 3) = max(0, 3+3) = 6 ← 使用了更新后的dp[2]
j=6: dp[6] = max(dp[6], dp[4] + 3) = max(0, 6+3) = 9 ← 使用了更新后的dp[4]
```
结果：物品1选择了3次，dp[6]=9

#### 4.4 核心洞察：扫描顺序的本质

**关键认知**：不管是0-1背包还是完全背包，在空间优化后，`dp[j-weight[i-1]]`都会被正序扫描先更新。

**两种背包的本质差异**：
- **0-1背包**：拒绝这种更新，需要的是`dp[i-1]`行的旧值（上一轮物品决策的结果）
- **完全背包**：接受这种更新，需要的是`dp[i]`行的新值（当前物品已做过选择的结果）

**具体分析**：
```java
// 空间优化后的状态转移（两种背包形式相同）
dp[j] = max(dp[j], dp[j-weight[i-1]] + value[i-1])

// 关键区别在于dp[j-weight[i-1]]的含义：
// 0-1背包：希望它是dp[i-1][j-weight[i-1]]（上一行的值）
// 完全背包：希望它是dp[i][j-weight[i-1]]（当前行的值）
```

**扫描顺序的必然性**：
- **0-1背包逆序扫描**：保护`dp[j-weight[i-1]]`不被提前更新，维持其作为"上一行旧值"的身份
- **完全背包正序扫描**：让`dp[j-weight[i-1]]`被提前更新，使其成为"当前行新值"，实现物品重复选择

#### 4.5 记忆口诀

- **0-1背包**：物品只能选一次 → 需要旧值 → 逆序扫描
- **完全背包**：物品可选多次 → 需要新值 → 正序扫描

### 4. 判断方法论

**步骤1：分析状态转移方程**
- 观察当前状态`dp[i][j]`依赖哪些其他状态
- 特别关注是否依赖`dp[i][j-k]`这样的"本行左边"状态

**步骤2：确定所需值的类型**
- **新值**：需要本轮循环中已经更新过的值 → j正序
- **旧值**：需要上一轮循环中的原始值 → j逆序

**步骤3：验证扫描顺序**
```java
// 0-1背包示例：为什么j要逆序？
// dp[j] = max(dp[j], dp[j-w[i]] + v[i])
// 
// 如果j正序：dp[j-w[i]]可能已被本轮更新，导致重复选择
// 如果j逆序：dp[j-w[i]]保持上一轮的值，避免重复选择

// 完全背包示例：为什么j可以正序？
// dp[j] = max(dp[j], dp[j-w[i]] + v[i])
//
// 正序扫描：dp[j-w[i]]使用本轮更新的值，实现物品重复选择
// 这正是完全背包所需要的特性
```

### 5. 空间优化的扫描考虑

当将二维DP优化为一维时，扫描顺序变得更加关键：

**背包类问题**：
```java
// 二维版本（扫描顺序相对自由）
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= capacity; j++) {
        dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);
    }
}

// 一维优化版本（必须逆序扫描j）
for (int i = 1; i <= n; i++) {
    for (int j = capacity; j >= w[i]; j--) { // 必须逆序！
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

**路径类问题**：
```java
// 二维版本
for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) {
        dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);
    }
}

// 一维优化版本（必须正序扫描j）
for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) { // 必须正序！
        dp[j] = grid[i][j] + min(dp[j], dp[j-1]);
    }
}
```

### 6. 核心判断标准

**终极判断法则**：
> 看状态转移方程中，当前状态需要的是"旧值"还是"新值"
> - 需要旧值 → 逆序扫描
> - 需要新值 → 正序扫描

这个规律不仅适用于二维DP，也适用于更高维度的动态规划问题。理解了依赖关系，就能正确确定任意维度的扫描顺序。

## 动态规划两大核心性质的代码体现

### 1. 最优子结构性质

**定义**：一个问题的最优解包含其子问题的最优解。

**在背包问题中的具体体现**：

**0-1背包状态转移方程**：
```java
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
```

**最优子结构体现在**：
- **第一项 `dp[i-1][j]`**：表示"不选第i个物品"时的最优解，这个解就是**前i-1个物品在容量j下的最优解**
- **第二项 `dp[i-1][j-w[i]] + v[i]`**：表示"选第i个物品"时的最优解，这个解等于**前i-1个物品在剩余容量j-w[i]下的最优解**加上当前物品价值

**完全背包状态转移方程**：
```java
dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])
```

**关键认知**：整个问题的最优解（dp[i][j]）完全由两个子问题的最优解组合而成，没有任何额外信息。

### 2. 重叠子问题性质

**定义**：在递归求解过程中，许多子问题会被重复计算。

**在代码中的具体体现**：

**从DFS递归结构看**：
```java
// knapsacksDfs方法中的递归调用
int no = knapsacksDfs(weights, values, item - 1, capacity);
int yes = knapsacksDfs(weights, values, item - 1, capacity - weights[item - 1]) + values[item - 1];
```

**重叠子问题的证据**：
- **同一个子问题被多次调用**：例如计算`f(5,10)`时，`f(3,7)`这个子问题可能在不同路径下被多次计算
- **状态空间远小于搜索空间**：虽然有2^n种选择组合，但只有`(n+1) × (capacity+1)`个**不同的子问题状态**

**从记忆化优化看**：
```java
// knapsacksMemoization方法中的缓存检查
if (memo[item][capacity] != -1) {
    return memo[item][capacity];
}
```

**这直接证明了重叠子问题的存在**：
- 如果没有重叠子问题，记忆化就没有意义
- 正是因为`f(i,j)`这个子问题会被多次访问，缓存才有价值

### 3. 具体示例验证

以物品`[2,3,4]`，价值`[4,5,6]`，容量`8`为例：

```
计算f(3,8)时：
├── 需要f(2,8)  ← 重叠子问题
│   ├── 需要f(1,8)  ← 重叠子问题
│   └── 需要f(1,5)  ← 重叠子问题
└── 需要f(2,4)  ← 重叠子问题
    ├── 需要f(1,4)  ← 重叠子问题（已计算过）
    └── 需要f(1,1)  ← 重叠子问题
```

可以看到`f(1,8)`、`f(1,5)`、`f(1,4)`等子问题被**多次重复计算**，这正是重叠子问题的典型特征。

### 4. 两大性质的统一认知框架

| 性质 | 在公式中的体现 | 在代码中的体现 | 优化意义 |
|------|----------------|----------------|----------|
| **最优子结构** | 当前状态由子状态最优解组合 | `max(子问题1, 子问题2)` | 保证局部最优→全局最优 |
| **重叠子问题** | 相同子状态被多次引用 | 记忆化缓存的必要性 | 指数级→多项式级优化 |

**核心洞察**：这两个性质共同构成了DP高效性的基础：
- **最优子结构**保证了我们可以用子问题的最优解构建原问题的最优解
- **重叠子问题**使得记忆化/动态规划成为可能，将时间复杂度从指数级降为多项式级

### 5. 从理论到实践的映射

**在记忆化搜索中**：
- **最优子结构**：体现在状态转移方程的构建上
- **重叠子问题**：体现在缓存机制的设计上

**在动态规划中**：
- **最优子结构**：体现在状态转移方程的正确性上
- **重叠子问题**：体现在迭代计算的顺序安排上

**关键认知**：理解这两个性质不仅有助于正确实现算法，更重要的是能够：
1. **验证算法的正确性**：确保状态转移方程确实体现了最优子结构
2. **优化算法效率**：通过识别重叠子问题来设计合适的缓存策略
3. **扩展到新问题**：判断一个新问题是否适合用DP解决