# 背包问题算法认知总结

## 三大算法模板

### 1. 普通递归搜索模板
```
1. 定义递归函数和参数（状态表示）
2. 处理边界条件（递归终止条件）
3. 处理约束条件（资源不足时的处理）
4. 枚举所有可能的决策选择
5. 递归求解子问题
6. 合并子问题结果，返回最优解
```

**适用范围**：
- 背包问题：95%适用
- 所有DP问题：85%适用
- 其他递归问题：70%适用

### 2. 记忆化搜索模板
```
1. 基于普通递归搜索
2. 初始化备忘录（关键：避开合法返回值，如用-1避开0）
3. 处理边界条件（递归终止）
4. 检查缓存：如果本层已计算，直接返回
   【关键认知】：每一层只处理本层的缓存，不处理子问题的缓存
5. 专门处理资源约束条件（如容量不足）
6. 枚举决策，递归求解子问题
7. 合并子问题结果
8. 缓存本层结果并返回
```

**关键认知**：
- **"避开合法值"**：用-1避开0这个合法返回值
- **"每层只处理本层缓存"**：不要替子问题做决定
- **"专门处理资源约束"**：约束不满足时的处理逻辑往往不同

### 3. 动态规划模板
```
1. 定义状态：dp[i][j]的含义
2. 处理边界条件和特殊情况
3. 初始化DP表（关键：使用合法值初始化，如边界状态设为0）
4. 【重要】：不使用递归，采用迭代方式（嵌套循环）
5. 确定状态转移顺序（通常是嵌套循环）
6. 在循环中：
   - 专门处理资源约束条件（如容量不足）
   - 枚举决策选择
   - 应用状态转移方程
   - 更新DP表
7. 返回目标状态的值
```

**关键认知**：
- **"使用合法值初始化"**：直接用0初始化边界状态（因为0就是正确答案）
- **"DP不做递归"**：用循环替代递归，避免栈溢出
- **"专门处理资源约束"**：这是背包类问题的核心

## 核心洞察：从"有重复组合"到"无重复组合"的优化

### 1. 暴力搜索（DFS）的认知
暴力搜索构建了一个**高度为n的决策树**：
- **树的高度**：n层（对应n个物品）
- **每层分叉**：2个选择（选或不选当前物品）
- **总节点数**：2^n个（指数级增长）
- **重复计算**：同一个子问题在不同路径下被多次访问

**决策树可视化**：
```
                   f(n, capacity)
                  /              \
        f(n-1, capacity)    f(n-1, capacity-w[n-1])
           /        \              /        \
  f(n-2,...)  f(n-2,...)  f(n-2,...)  f(n-2,...)
```

**复杂度分析**：
- 时间复杂度：O(2^n) - 对应树的节点总数
- 空间复杂度：O(n) - 递归调用栈的深度（树的高度）

### 2. 记忆化搜索的优化原理
记忆化搜索实现了从**"有重复组合"到"无重复组合"**的关键优化：

**优化前（DFS）**：
- 同一个子问题被重复计算多次
- 形成"有重复组合"的搜索过程
- 时间复杂度：指数级 O(2^n)

**优化后（记忆化搜索）**：
- 每个子问题只计算一次
- 形成"无重复组合"的搜索过程
- 时间复杂度：多项式级 O(n × capacity)

### 3. 等价性认知
记忆化搜索的复杂度分析：
- **状态总数**：(n+1) × (capacity+1) 个不同的子问题
- **每个状态计算时间**：O(1) - 只需常数时间的比较和加法
- **总时间复杂度**：状态数 × 每个状态的计算时间 = O(n × capacity)

**关键认知**：这确实等价于一次"没有重复的遍历搜索"：
- 相当于遍历了一个 (n+1) × (capacity+1) 的二维表格
- 每个格子只计算一次，没有重复计算
- 与嵌套循环 `for(i=0..n) for(j=0..capacity)` 的遍历次数完全相同

### 4. 一般性结论
对于动态规划问题：
- **暴力搜索**：通常对应一个高度为n的决策树，每层分叉数由选择数决定
- **记忆化优化**：将指数级复杂度降为多项式级复杂度
- **双层for循环**：本质上都是"无重复选择"的遍历过程

这个认知适用于所有能用动态规划解决的问题，是理解算法优化的核心钥匙。

## 模板对比总结

| 特征 | 普通递归搜索 | 记忆化搜索 | 动态规划 |
|------|-------------|------------|----------|
| **实现方式** | 递归 | 递归+缓存 | 迭代循环 |
| **时间复杂度** | O(2^n) | O(n×capacity) | O(n×capacity) |
| **空间复杂度** | O(n) | O(n×capacity) | O(n×capacity) |
| **缓存策略** | 无 | 避开合法值(-1) | 使用合法值(0) |
| **计算顺序** | 自顶向下 | 自顶向下 | 自底向上 |
| **资源约束处理** | 专门处理 | 专门处理 | 专门处理 |
| **适用场景** | 理解问题结构 | 优化递归 | 生产环境 |

## 多维DP的等价性认知

### 1. 一维DP的等价性认知
**状态空间**：线性的一维表格
- **状态总数**：n+1 个不同的子问题（对应dp[0..n]）
- **每个状态计算时间**：O(1) - 常数时间的比较和加法
- **总时间复杂度**：状态数 × 每个状态的计算时间 = **O(n)**

**关键认知**：这等价于一次"没有重复的线性遍历"：
- 相当于从左到右遍历了一个长度为 n+1 的一维数组
- 每个位置只计算一次，没有重复计算
- 与单层循环 `for(i=0..n)` 的遍历次数完全相同

**典型应用**：斐波那契数列、最长递增子序列、一维背包

### 2. 二维DP的等价性认知
**状态空间**：矩形的二维表格
- **状态总数**：(n+1) × (m+1) 个不同的子问题（对应dp[0..n][0..m]）
- **每个状态计算时间**：O(1) - 常数时间的比较和加法
- **总时间复杂度**：状态数 × 每个状态的计算时间 = **O(n × m)**

**关键认知**：这等价于一次"没有重复的矩阵遍历"：
- 相当于逐行逐列遍历了一个 (n+1) × (m+1) 的二维矩阵
- 每个格子只计算一次，没有重复计算
- 与嵌套循环 `for(i=0..n) for(j=0..m)` 的遍历次数完全相同

**典型应用**：最长公共子序列、编辑距离、二维背包、区间DP

### 3. 三维DP的等价性认知
**状态空间**：立方体的三维空间
- **状态总数**：(n+1) × (m+1) × (k+1) 个不同的子问题（对应dp[0..n][0..m][0..k]）
- **每个状态计算时间**：O(1) - 常数时间的比较和加法
- **总时间复杂度**：状态数 × 每个状态的计算时间 = **O(n × m × k)**

**关键认知**：这等价于一次"没有重复的三维空间遍历"：
- 相当于逐层逐行逐列遍历了一个 (n+1) × (m+1) × (k+1) 的三维立方体
- 每个空间点只计算一次，没有重复计算
- 与三重嵌套循环 `for(i=0..n) for(j=0..m) for(k=0..k)` 的遍历次数完全相同

**典型应用**：三维背包、多字符串比较、复杂状态转移问题

### 4. 统一认知框架
对于任意维度的动态规划问题：

| 维度 | 状态空间形状 | 状态总数 | 时间复杂度 | 遍历方式 |
|------|-------------|----------|------------|----------|
| **一维** | 线性数组 | n+1 | O(n) | 单层循环 |
| **二维** | 矩形矩阵 | (n+1)×(m+1) | O(n×m) | 双重循环 |
| **三维** | 立方体 | (n+1)×(m+1)×(k+1) | O(n×m×k) | 三重循环 |
| **d维** | d维超立方体 | ∏(xi+1) | O(∏xi) | d重循环 |

**核心洞察**：无论维度如何变化，动态规划的本质都是**"对状态空间的一次完整且无重复的遍历"**。维度的增加只是将遍历空间从一维直线扩展到二维平面、三维空间，乃至更高维的超空间，但优化原理和复杂度分析的方法论完全一致。